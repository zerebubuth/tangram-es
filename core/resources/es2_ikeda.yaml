cameras:
  camera1:
    focal_length: [[16, 2], [20, 6]]
    type: perspective
    vanishing_point: [-250, -250]
styles:
  roads:
    animated: true
    texcoords: true
    base: lines
    shaders:
      blocks:
        vertex_shader: "precision highp float;\nuniform mat4 u_model;\nuniform mat4 u_view;\nuniform mat4 u_proj;\nuniform mat3 u_normalMatrix;\nuniform vec3 u_map_position;\nuniform vec3 u_tile_origin;\nattribute vec4 a_position;\nattribute vec4 a_color;\nattribute vec4 a_extrude;\nattribute vec2 a_texcoord;\nattribute float a_layer;\nvarying vec4 v_world_position;\nvarying vec4 v_position;\nvarying vec4 v_color;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvarying vec3 v_pos;\nvoid main ()\n{\n  float width_1;\n  vec4 position_2;\n  position_2.zw = a_position.zw;\n  v_color = a_color;\n  v_texcoord = a_texcoord;\n  v_normal = (u_normalMatrix * vec3(0.0, 0.0, 1.0));\n  float tmpvar_3;\n  float tmpvar_4;\n  tmpvar_4 = abs(u_tile_origin.z);\n  tmpvar_3 = (u_map_position.z - tmpvar_4);\n  width_1 = (a_extrude.z + (a_extrude.w * tmpvar_3));\n  width_1 = (width_1 * exp2(-(tmpvar_3)));\n  position_2.xy = (a_position.xy + (a_extrude.xy * width_1));\n  position_2 = (u_model * position_2);\n  vec4 tmpvar_5;\n  tmpvar_5.zw = vec2(0.0, 0.0);\n  tmpvar_5.xy = u_map_position.xy;\n  v_world_position = (position_2 + (vec4(mod (tmpvar_5, 100000.0))));\n  v_pos = (a_position.xyz * 32767.0);\n  v_position = (u_view * position_2);\n  gl_Position = (u_proj * v_position);\n  gl_Position.z = (gl_Position.z / (1.0 + (0.1 * \n    (tmpvar_4 - u_tile_origin.z)\n  )));\n  gl_Position.z = (gl_Position.z - ((a_layer * 1.5e-05) * gl_Position.w));\n}\n\n"
        fragment_shader: "precision highp float;\nstruct Material {\n  vec4 ambient;\n  vec4 diffuse;\n};\nuniform float u_time;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\nuniform Material u_material;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1 = u_material.ambient;\n  float t_2;\n  mediump vec4 color_3;\n  color_3 = v_color;\n  float tmpvar_4;\n  tmpvar_4 = (12.0 * u_time);\n  t_2 = tmpvar_4;\n  if ((v_color.x < 0.5)) {\n    float tmpvar_5;\n    tmpvar_5 = fract(v_texcoord.x);\n    if ((tmpvar_5 < 0.5)) {\n      t_2 = -(tmpvar_4);\n    };\n  };\n  float tmpvar_6;\n  tmpvar_6 = (v_texcoord.y * 100.0);\n  color_3.x = float((fract(\n    (sin((floor(tmpvar_6) - floor(\n      (t_2 + 0.025)\n    ))) * 43758.55)\n  ) >= 0.8));\n  color_3.y = float((fract(\n    (sin((floor(tmpvar_6) - floor(t_2))) * 43758.55)\n  ) >= 0.8));\n  color_3.z = float((fract(\n    (sin((floor(tmpvar_6) - floor(\n      (t_2 - 0.025)\n    ))) * 43758.55)\n  ) >= 0.8));\n  color_3.xyz = (color_3.xyz * (float(\n    (v_texcoord.x >= 0.1)\n  ) - float(\n    (v_texcoord.x >= 0.9)\n  )));\n  mediump vec4 color_7;\n  color_7 = (color_3 * tmpvar_1);\n  mediump vec4 tmpvar_8;\n  tmpvar_8 = clamp (color_7, 0.0, 1.0);\n  color_7 = tmpvar_8;\n  color_3 = tmpvar_8;\n  gl_FragColor = tmpvar_8;\n}\n\n"
      defines:
        STYLE: roads
  buildingsLines:
    texcoords: true
    base: lines
    lighting: false
    shaders:
      defines:
        STYLE: buildingsLines
      blocks:
        fragment_shader: "precision highp float;\nvarying vec4 v_color;\nvoid main ()\n{\n  gl_FragColor = v_color;\n}\n\n"
        vertex_shader: "precision highp float;\nuniform mat4 u_model;\nuniform mat4 u_view;\nuniform mat4 u_proj;\nuniform mat3 u_normalMatrix;\nuniform vec3 u_map_position;\nuniform vec3 u_tile_origin;\nattribute vec4 a_position;\nattribute vec4 a_color;\nattribute vec4 a_extrude;\nattribute vec2 a_texcoord;\nattribute float a_layer;\nvarying vec4 v_world_position;\nvarying vec4 v_position;\nvarying vec4 v_color;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvarying vec3 v_pos;\nvoid main ()\n{\n  float width_1;\n  vec4 position_2;\n  position_2.zw = a_position.zw;\n  v_color = a_color;\n  v_texcoord = a_texcoord;\n  v_normal = (u_normalMatrix * vec3(0.0, 0.0, 1.0));\n  float tmpvar_3;\n  float tmpvar_4;\n  tmpvar_4 = abs(u_tile_origin.z);\n  tmpvar_3 = (u_map_position.z - tmpvar_4);\n  width_1 = (a_extrude.z + (a_extrude.w * tmpvar_3));\n  width_1 = (width_1 * exp2(-(tmpvar_3)));\n  position_2.xy = (a_position.xy + (a_extrude.xy * width_1));\n  position_2 = (u_model * position_2);\n  vec4 tmpvar_5;\n  tmpvar_5.zw = vec2(0.0, 0.0);\n  tmpvar_5.xy = u_map_position.xy;\n  v_world_position = (position_2 + (vec4(mod (tmpvar_5, 100000.0))));\n  v_pos = (a_position.xyz * 32767.0);\n  position_2.z = (position_2.z * max (1.0, (0.5 + \n    ((1.0 - (u_map_position.z / 20.0)) * 5.0)\n  )));\n  v_position = (u_view * position_2);\n  gl_Position = (u_proj * v_position);\n  gl_Position.z = (gl_Position.z / (1.0 + (0.1 * \n    (tmpvar_4 - u_tile_origin.z)\n  )));\n  gl_Position.z = (gl_Position.z - ((a_layer * 1.5e-05) * gl_Position.w));\n}\n\n"
  numeric-grid:
    animated: true
    base: polygons
    shaders:
      blocks:
        fragment_shader: "precision highp float;\nstruct Material {\n  vec4 ambient;\n  vec4 diffuse;\n};\nuniform vec3 u_map_position;\nvarying vec4 v_color;\nuniform Material u_material;\nvarying vec3 v_pos;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1 = u_material.ambient;\n  mediump vec4 color_2;\n  color_2.w = v_color.w;\n  vec2 tmpvar_3;\n  vec2 tmpvar_4;\n  tmpvar_4 = (v_pos.xy * 0.0002445);\n  tmpvar_3 = fract(tmpvar_4);\n  vec3 color_5;\n  vec2 tmpvar_6;\n  tmpvar_6 = (fract(tmpvar_4) * 100.0);\n  float tmpvar_7;\n  float tmpvar_8;\n  tmpvar_8 = fract(u_map_position.z);\n  tmpvar_7 = (0.5 + ((1.0 - tmpvar_8) * 0.1));\n  vec2 tmpvar_9;\n  tmpvar_9 = fract((tmpvar_6 * 0.02));\n  color_5 = (vec3(0.1, 0.0, 0.0) * (1.0 - (\n    float((tmpvar_9.x >= (tmpvar_7 * 0.02)))\n   * \n    float((tmpvar_9.y >= (tmpvar_7 * 0.02)))\n  )));\n  vec2 tmpvar_10;\n  tmpvar_10 = fract((tmpvar_6 * 0.01));\n  color_5 = (color_5 + (vec3(0.5, 0.0, 0.0) * (1.0 - \n    (float((tmpvar_10.x >= (tmpvar_7 * 0.01))) * float((tmpvar_10.y >= (tmpvar_7 * 0.01))))\n  )));\n  vec2 tmpvar_11;\n  tmpvar_11 = fract((tmpvar_6 * 0.1));\n  color_5 = (color_5 + (0.1 * (1.0 - \n    (float((tmpvar_11.x >= (tmpvar_7 * 0.1))) * float((tmpvar_11.y >= (tmpvar_7 * 0.1))))\n  )));\n  vec3 color_12;\n  vec2 tmpvar_13;\n  tmpvar_13 = (200.0 * fract(tmpvar_4));\n  float tmpvar_14;\n  tmpvar_14 = (0.5 + ((1.0 - tmpvar_8) * 0.1));\n  vec2 tmpvar_15;\n  tmpvar_15 = fract((tmpvar_13 * 0.02));\n  color_12 = (vec3(0.1, 0.0, 0.0) * (1.0 - (\n    float((tmpvar_15.x >= (tmpvar_14 * 0.02)))\n   * \n    float((tmpvar_15.y >= (tmpvar_14 * 0.02)))\n  )));\n  vec2 tmpvar_16;\n  tmpvar_16 = fract((tmpvar_13 * 0.01));\n  color_12 = (color_12 + (vec3(0.5, 0.0, 0.0) * (1.0 - \n    (float((tmpvar_16.x >= (tmpvar_14 * 0.01))) * float((tmpvar_16.y >= (tmpvar_14 * 0.01))))\n  )));\n  vec2 tmpvar_17;\n  tmpvar_17 = fract((tmpvar_13 * 0.1));\n  color_12 = (color_12 + (0.1 * (1.0 - \n    (float((tmpvar_17.x >= (tmpvar_14 * 0.1))) * float((tmpvar_17.y >= (tmpvar_14 * 0.1))))\n  )));\n  color_2.xyz = mix (color_5, color_12, tmpvar_8);\n  float tmpvar_18;\n  tmpvar_18 = (0.0001 + tmpvar_8);\n  vec2 tmpvar_19;\n  tmpvar_19 = fract((tmpvar_3 + 0.5));\n  vec2 size_20;\n  size_20 = (vec2(0.08, 0.08) * (1.0 + (1.0 - tmpvar_18)));\n  vec2 tmpvar_21;\n  tmpvar_21.x = (size_20.x * 0.5);\n  tmpvar_21.y = (size_20.y * 0.125);\n  vec2 size_22;\n  vec2 uv_23;\n  size_22 = (vec2(0.5, 0.5) - (tmpvar_21 * 0.5));\n  vec2 tmpvar_24;\n  tmpvar_24 = clamp (((tmpvar_19 - size_22) / (\n    (size_22 + vec2(0.001, 0.001))\n   - size_22)), 0.0, 1.0);\n  vec2 tmpvar_25;\n  tmpvar_25 = clamp (((\n    (vec2(1.0, 1.0) - tmpvar_19)\n   - size_22) / (\n    (size_22 + vec2(0.001, 0.001))\n   - size_22)), 0.0, 1.0);\n  uv_23 = ((tmpvar_24 * (tmpvar_24 * \n    (3.0 - (2.0 * tmpvar_24))\n  )) * (tmpvar_25 * (tmpvar_25 * \n    (3.0 - (2.0 * tmpvar_25))\n  )));\n  vec2 tmpvar_26;\n  tmpvar_26.x = (size_20.y * 0.125);\n  tmpvar_26.y = (size_20.x * 0.5);\n  vec2 size_27;\n  vec2 uv_28;\n  size_27 = (vec2(0.5, 0.5) - (tmpvar_26 * 0.5));\n  vec2 tmpvar_29;\n  tmpvar_29 = clamp (((tmpvar_19 - size_27) / (\n    (size_27 + vec2(0.001, 0.001))\n   - size_27)), 0.0, 1.0);\n  vec2 tmpvar_30;\n  tmpvar_30 = clamp (((\n    (vec2(1.0, 1.0) - tmpvar_19)\n   - size_27) / (\n    (size_27 + vec2(0.001, 0.001))\n   - size_27)), 0.0, 1.0);\n  uv_28 = ((tmpvar_29 * (tmpvar_29 * \n    (3.0 - (2.0 * tmpvar_29))\n  )) * (tmpvar_30 * (tmpvar_30 * \n    (3.0 - (2.0 * tmpvar_30))\n  )));\n  color_2.xyz = (color_2.xyz * (1.0 - clamp (\n    ((uv_23.x * uv_23.y) + (uv_28.x * uv_28.y))\n  , 0.0, 1.0)));\n  vec2 size_31;\n  size_31 = (vec2(0.05, 0.05) * (1.0 + (1.0 - tmpvar_18)));\n  vec2 tmpvar_32;\n  tmpvar_32.x = (size_31.x * 0.5);\n  tmpvar_32.y = (size_31.y * 0.125);\n  vec2 size_33;\n  vec2 uv_34;\n  size_33 = (vec2(0.5, 0.5) - (tmpvar_32 * 0.5));\n  vec2 tmpvar_35;\n  tmpvar_35 = clamp (((tmpvar_19 - size_33) / (\n    (size_33 + vec2(0.001, 0.001))\n   - size_33)), 0.0, 1.0);\n  vec2 tmpvar_36;\n  tmpvar_36 = clamp (((\n    (vec2(1.0, 1.0) - tmpvar_19)\n   - size_33) / (\n    (size_33 + vec2(0.001, 0.001))\n   - size_33)), 0.0, 1.0);\n  uv_34 = ((tmpvar_35 * (tmpvar_35 * \n    (3.0 - (2.0 * tmpvar_35))\n  )) * (tmpvar_36 * (tmpvar_36 * \n    (3.0 - (2.0 * tmpvar_36))\n  )));\n  vec2 tmpvar_37;\n  tmpvar_37.x = (size_31.y * 0.125);\n  tmpvar_37.y = (size_31.x * 0.5);\n  vec2 size_38;\n  vec2 uv_39;\n  size_38 = (vec2(0.5, 0.5) - (tmpvar_37 * 0.5));\n  vec2 tmpvar_40;\n  tmpvar_40 = clamp (((tmpvar_19 - size_38) / (\n    (size_38 + vec2(0.001, 0.001))\n   - size_38)), 0.0, 1.0);\n  vec2 tmpvar_41;\n  tmpvar_41 = clamp (((\n    (vec2(1.0, 1.0) - tmpvar_19)\n   - size_38) / (\n    (size_38 + vec2(0.001, 0.001))\n   - size_38)), 0.0, 1.0);\n  uv_39 = ((tmpvar_40 * (tmpvar_40 * \n    (3.0 - (2.0 * tmpvar_40))\n  )) * (tmpvar_41 * (tmpvar_41 * \n    (3.0 - (2.0 * tmpvar_41))\n  )));\n  color_2.xyz = (color_2.xyz + (vec3(0.9, 0.9, 0.9) * clamp (\n    ((uv_34.x * uv_34.y) + (uv_39.x * uv_39.y))\n  , 0.0, 1.0)));\n  vec2 tmpvar_42;\n  tmpvar_42 = (vec2(mod ((tmpvar_3 * (30.0 + \n    (30.0 * tmpvar_18)\n  )), 60.0)));\n  vec2 tmpvar_43;\n  tmpvar_43 = floor(tmpvar_42);\n  if ((((tmpvar_43.y == 1.0) && (tmpvar_43.x > 0.0)) && (tmpvar_43.x < 7.0))) {\n    vec2 tmpvar_44;\n    tmpvar_44 = fract(tmpvar_42);\n    vec2 st_45;\n    vec2 borders_46;\n    st_45.x = ((tmpvar_44.x * 2.0) - 0.5);\n    st_45.y = ((tmpvar_44.y * 1.2) - 0.1);\n    borders_46 = (vec2(greaterThanEqual (st_45, vec2(0.0, 0.0))) * vec2(greaterThanEqual (\n      (1.0 - st_45)\n    , vec2(0.0, 0.0))));\n    color_2.xyz = (color_2.xyz + vec3((borders_46.x * borders_46.y)));\n  } else {\n    if ((((tmpvar_43.y == 2.0) && (tmpvar_43.x > 0.0)) && (tmpvar_43.x < 8.0))) {\n      vec2 tmpvar_47;\n      tmpvar_47 = fract(tmpvar_42);\n      vec2 st_48;\n      vec2 borders_49;\n      st_48.x = ((tmpvar_47.x * 2.0) - 0.5);\n      st_48.y = ((tmpvar_47.y * 1.2) - 0.1);\n      borders_49 = (vec2(greaterThanEqual (st_48, vec2(0.0, 0.0))) * vec2(greaterThanEqual (\n        (1.0 - st_48)\n      , vec2(0.0, 0.0))));\n      color_2.xyz = (color_2.xyz + vec3((borders_49.x * borders_49.y)));\n    };\n  };\n  mediump vec4 color_50;\n  color_50 = (color_2 * tmpvar_1);\n  mediump vec4 tmpvar_51;\n  tmpvar_51 = clamp (color_50, 0.0, 1.0);\n  color_50 = tmpvar_51;\n  color_2 = tmpvar_51;\n  gl_FragColor = tmpvar_51;\n}\n\n"
        vertex_shader: "precision highp float;\nuniform mat4 u_model;\nuniform mat4 u_view;\nuniform mat4 u_proj;\nuniform mat3 u_normalMatrix;\nuniform vec3 u_map_position;\nuniform vec3 u_tile_origin;\nattribute vec4 a_position;\nattribute vec4 a_color;\nattribute vec3 a_normal;\nattribute vec2 a_texcoord;\nattribute float a_layer;\nvarying vec4 v_world_position;\nvarying vec4 v_position;\nvarying vec4 v_color;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvarying vec3 v_pos;\nvoid main ()\n{\n  vec4 position_1;\n  v_color = a_color;\n  v_texcoord = a_texcoord;\n  v_normal = normalize((u_normalMatrix * a_normal));\n  position_1 = (u_model * a_position);\n  vec4 tmpvar_2;\n  tmpvar_2.zw = vec2(0.0, 0.0);\n  tmpvar_2.xy = u_map_position.xy;\n  v_world_position = (position_1 + (vec4(mod (tmpvar_2, 100000.0))));\n  v_pos = (a_position.xyz * 32767.0);\n  v_position = (u_view * position_1);\n  gl_Position = (u_proj * v_position);\n  gl_Position.z = (gl_Position.z / (1.0 + (0.1 * \n    (abs(u_tile_origin.z) - u_tile_origin.z)\n  )));\n  gl_Position.z = (gl_Position.z - ((a_layer * 1.5e-05) * gl_Position.w));\n}\n\n"
      defines:
        STYLE: numeric-grid
  simple-grid:
    base: polygons
    shaders:
      blocks:
        vertex_shader: "precision highp float;\nuniform mat4 u_model;\nuniform mat4 u_view;\nuniform mat4 u_proj;\nuniform mat3 u_normalMatrix;\nuniform vec3 u_map_position;\nuniform vec3 u_tile_origin;\nattribute vec4 a_position;\nattribute vec4 a_color;\nattribute vec3 a_normal;\nattribute vec2 a_texcoord;\nattribute float a_layer;\nvarying vec4 v_world_position;\nvarying vec4 v_position;\nvarying vec4 v_color;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvarying vec3 v_pos;\nvoid main ()\n{\n  vec4 position_1;\n  v_color = a_color;\n  v_texcoord = a_texcoord;\n  v_normal = normalize((u_normalMatrix * a_normal));\n  position_1 = (u_model * a_position);\n  vec4 tmpvar_2;\n  tmpvar_2.zw = vec2(0.0, 0.0);\n  tmpvar_2.xy = u_map_position.xy;\n  v_world_position = (position_1 + (vec4(mod (tmpvar_2, 100000.0))));\n  v_pos = (a_position.xyz * 32767.0);\n  v_position = (u_view * position_1);\n  gl_Position = (u_proj * v_position);\n  gl_Position.z = (gl_Position.z / (1.0 + (0.1 * \n    (abs(u_tile_origin.z) - u_tile_origin.z)\n  )));\n  gl_Position.z = (gl_Position.z - ((a_layer * 1.5e-05) * gl_Position.w));\n}\n\n"
        fragment_shader: "precision highp float;\nstruct Material {\n  vec4 ambient;\n  vec4 diffuse;\n};\nuniform vec3 u_map_position;\nuniform vec3 u_tile_origin;\nuniform float u_time;\nvarying vec4 v_color;\nuniform Material u_material;\nvarying vec3 v_pos;\nvoid main ()\n{\n  mediump vec4 color_1;\n  color_1.w = v_color.w;\n  vec3 color_2;\n  vec2 tmpvar_3;\n  vec2 tmpvar_4;\n  tmpvar_4 = (v_pos.xy * 0.0002445);\n  tmpvar_3 = (fract(tmpvar_4) * 100.0);\n  float tmpvar_5;\n  float tmpvar_6;\n  tmpvar_6 = fract(u_map_position.z);\n  tmpvar_5 = (0.5 + ((1.0 - tmpvar_6) * 0.1));\n  vec2 tmpvar_7;\n  tmpvar_7 = fract((tmpvar_3 * 0.02));\n  color_2 = (vec3(0.1, 0.0, 0.0) * (1.0 - (\n    float((tmpvar_7.x >= (tmpvar_5 * 0.02)))\n   * \n    float((tmpvar_7.y >= (tmpvar_5 * 0.02)))\n  )));\n  vec2 tmpvar_8;\n  tmpvar_8 = fract((tmpvar_3 * 0.01));\n  color_2 = (color_2 + (vec3(0.5, 0.0, 0.0) * (1.0 - \n    (float((tmpvar_8.x >= (tmpvar_5 * 0.01))) * float((tmpvar_8.y >= (tmpvar_5 * 0.01))))\n  )));\n  vec2 tmpvar_9;\n  tmpvar_9 = fract((tmpvar_3 * 0.1));\n  color_2 = (color_2 + (0.1 * (1.0 - \n    (float((tmpvar_9.x >= (tmpvar_5 * 0.1))) * float((tmpvar_9.y >= (tmpvar_5 * 0.1))))\n  )));\n  vec3 color_10;\n  vec2 tmpvar_11;\n  tmpvar_11 = (200.0 * fract(tmpvar_4));\n  float tmpvar_12;\n  tmpvar_12 = (0.5 + ((1.0 - tmpvar_6) * 0.1));\n  vec2 tmpvar_13;\n  tmpvar_13 = fract((tmpvar_11 * 0.02));\n  color_10 = (vec3(0.1, 0.0, 0.0) * (1.0 - (\n    float((tmpvar_13.x >= (tmpvar_12 * 0.02)))\n   * \n    float((tmpvar_13.y >= (tmpvar_12 * 0.02)))\n  )));\n  vec2 tmpvar_14;\n  tmpvar_14 = fract((tmpvar_11 * 0.01));\n  color_10 = (color_10 + (vec3(0.5, 0.0, 0.0) * (1.0 - \n    (float((tmpvar_14.x >= (tmpvar_12 * 0.01))) * float((tmpvar_14.y >= (tmpvar_12 * 0.01))))\n  )));\n  vec2 tmpvar_15;\n  tmpvar_15 = fract((tmpvar_11 * 0.1));\n  color_10 = (color_10 + (0.1 * (1.0 - \n    (float((tmpvar_15.x >= (tmpvar_12 * 0.1))) * float((tmpvar_15.y >= (tmpvar_12 * 0.1))))\n  )));\n  color_1.xyz = (v_color.xyz * mix (color_2, color_10, tmpvar_6));\n  vec2 tmpvar_16;\n  tmpvar_16 = (u_tile_origin.xy + floor((\n    fract(tmpvar_4)\n   * 2.0)));\n  float tmpvar_17;\n  tmpvar_17 = ((u_time * 0.8) + fract((\n    (10000.0 * sin(((17.0 * tmpvar_16.x) + (tmpvar_16.y * 0.1))))\n   * \n    (0.1 + abs(sin((\n      (tmpvar_16.y * 13.0)\n     + tmpvar_16.x))))\n  )));\n  vec2 p_18;\n  p_18 = (tmpvar_16 + floor(tmpvar_17));\n  color_1.xyz = (color_1.xyz + (float(\n    (fract(((10000.0 * \n      sin(((17.0 * p_18.x) + (p_18.y * 0.1)))\n    ) * (0.1 + \n      abs(sin(((p_18.y * 13.0) + p_18.x)))\n    ))) >= 0.9)\n  ) * (1.0 - \n    fract(tmpvar_17)\n  )));\n  mediump vec4 color_19;\n  color_19 = (color_1 * u_material.ambient);\n  mediump vec4 tmpvar_20;\n  tmpvar_20 = clamp (color_19, 0.0, 1.0);\n  color_19 = tmpvar_20;\n  color_1 = tmpvar_20;\n  gl_FragColor = tmpvar_20;\n}\n\n"
      defines:
        STYLE: simple-grid
  buildings:
    animated: true
    texcoords: true
    base: polygons
    shaders:
      defines:
        STYLE: buildings
      blocks:
        fragment_shader: "precision highp float;\nstruct Material {\n  vec4 ambient;\n  vec4 diffuse;\n};\nuniform float u_time;\nvarying vec4 v_world_position;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\nuniform Material u_material;\nvarying vec3 v_normalModel;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1 = u_material.ambient;\n  mediump vec4 color_2;\n  color_2 = v_color;\n  if ((v_normalModel.z == 0.0)) {\n    float tmpvar_3;\n    tmpvar_3 = fract((sin(\n      (((0.212655 * v_color.x) + (0.715158 * v_color.y)) + (0.072187 * v_color.z))\n    ) * 43758.55));\n    float tmpvar_4;\n    tmpvar_4 = (0.5 + (fract(\n      ((10000.0 * sin((\n        (17.0 * v_color.x)\n       + \n        (v_color.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((v_color.y * 13.0) + v_color.x)\n      ))))\n    ) * 0.5));\n    if ((tmpvar_3 > 0.3)) {\n      float pct_5;\n      vec2 vel_6;\n      vec2 ipos_7;\n      vec2 st_8;\n      st_8.x = v_texcoord.x;\n      st_8.y = (v_texcoord.y * (1.0 + (tmpvar_4 * 2.0)));\n      st_8.y = fract(st_8.y);\n      st_8 = (st_8 * vec2(50.0, 10.0));\n      vec2 tmpvar_9;\n      tmpvar_9.x = 0.0;\n      tmpvar_9.y = floor((v_texcoord.y * (1.0 + \n        (tmpvar_4 * 5.0)\n      )));\n      ipos_7 = (floor(st_8) + tmpvar_9);\n      vel_6 = (floor(vec2((u_time * 6.0))) * vec2(-1.0, 0.0));\n      vel_6 = (vel_6 * ((\n        float(((float(mod (ipos_7.y, 2.0))) >= 1.0))\n       - 0.5) * 2.0));\n      vel_6 = (vel_6 * fract((\n        sin(ipos_7.y)\n       * 43758.55)));\n      float tmpvar_10;\n      tmpvar_10 = (float(mod (((\n        (u_time * 20.0)\n       * \n        (1.0 + (tmpvar_3 * 0.5))\n      ) + (4324.0 * tmpvar_4)), 500.0)));\n      float tmpvar_11;\n      tmpvar_11 = floor((tmpvar_10 / 50.0));\n      vec2 tmpvar_12;\n      tmpvar_12.x = (float(mod (tmpvar_10, 50.0)));\n      tmpvar_12.y = tmpvar_11;\n      pct_5 = float((ipos_7.y >= (10.0 - tmpvar_11)));\n      pct_5 = (pct_5 + ((1.0 - \n        float((ipos_7.x >= tmpvar_12.x))\n      ) * float(\n        ((ipos_7.y + 1.0) >= (10.0 - tmpvar_11))\n      )));\n      float tmpvar_13;\n      tmpvar_13 = clamp (pct_5, 0.0, 1.0);\n      pct_5 = tmpvar_13;\n      vec2 tmpvar_14;\n      tmpvar_14 = floor(((st_8 + vel_6) + vec2(0.1, 0.0)));\n      color_2.x = (tmpvar_13 * fract((\n        (10000.0 * sin(((17.0 * tmpvar_14.x) + (tmpvar_14.y * 0.1))))\n       * \n        (0.1 + abs(sin((\n          (tmpvar_14.y * 13.0)\n         + tmpvar_14.x))))\n      )));\n      vec2 tmpvar_15;\n      tmpvar_15 = floor((st_8 + vel_6));\n      color_2.y = (tmpvar_13 * fract((\n        (10000.0 * sin(((17.0 * tmpvar_15.x) + (tmpvar_15.y * 0.1))))\n       * \n        (0.1 + abs(sin((\n          (tmpvar_15.y * 13.0)\n         + tmpvar_15.x))))\n      )));\n      vec2 tmpvar_16;\n      tmpvar_16 = floor(((st_8 + vel_6) - vec2(0.1, 0.0)));\n      color_2.z = (tmpvar_13 * fract((\n        (10000.0 * sin(((17.0 * tmpvar_16.x) + (tmpvar_16.y * 0.1))))\n       * \n        (0.1 + abs(sin((\n          (tmpvar_16.y * 13.0)\n         + tmpvar_16.x))))\n      )));\n      mediump vec3 tmpvar_17;\n      tmpvar_17 = clamp (((color_2.xyz * color_2.xyz) / tmpvar_4), 0.0, 1.0);\n      color_2.xyz = (tmpvar_17 * (tmpvar_17 * (3.0 - \n        (2.0 * tmpvar_17)\n      )));\n      color_2.xyz = (color_2.xyz * (float(\n        (fract((st_8.x + vel_6.x)) >= 0.1)\n      ) * float(\n        (fract((st_8.y + vel_6.y)) >= 0.1)\n      )));\n    } else {\n      vec2 vel_18;\n      vec2 st_19;\n      vec2 tmpvar_20;\n      tmpvar_20.x = v_texcoord.x;\n      tmpvar_20.y = (v_world_position.z * 0.005);\n      st_19 = (tmpvar_20 * vec2(100.0, 20.0));\n      vel_18 = (vec2((u_time * 100.0)) * (vec2(-1.0, 0.0) * fract(\n        (sin((1.0 + floor(st_19).y)) * 43758.55)\n      )));\n      vec2 tmpvar_21;\n      tmpvar_21 = floor(((st_19 + vec2(0.1, 0.0)) + vel_18));\n      vec2 p_22;\n      p_22 = (100.0 + (tmpvar_21 * 1e-06));\n      color_2.x = float(((\n        fract(((10000.0 * sin(\n          ((17.0 * p_22.x) + (p_22.y * 0.1))\n        )) * (0.1 + abs(\n          sin(((p_22.y * 13.0) + p_22.x))\n        ))))\n       + \n        (fract((sin(tmpvar_21.x) * 43758.55)) * 0.5)\n      ) >= tmpvar_4));\n      vec2 tmpvar_23;\n      tmpvar_23 = floor((st_19 + vel_18));\n      vec2 p_24;\n      p_24 = (100.0 + (tmpvar_23 * 1e-06));\n      color_2.y = float(((\n        fract(((10000.0 * sin(\n          ((17.0 * p_24.x) + (p_24.y * 0.1))\n        )) * (0.1 + abs(\n          sin(((p_24.y * 13.0) + p_24.x))\n        ))))\n       + \n        (fract((sin(tmpvar_23.x) * 43758.55)) * 0.5)\n      ) >= tmpvar_4));\n      vec2 tmpvar_25;\n      tmpvar_25 = floor(((st_19 - vec2(0.1, 0.0)) + vel_18));\n      vec2 p_26;\n      p_26 = (100.0 + (tmpvar_25 * 1e-06));\n      color_2.z = float(((\n        fract(((10000.0 * sin(\n          ((17.0 * p_26.x) + (p_26.y * 0.1))\n        )) * (0.1 + abs(\n          sin(((p_26.y * 13.0) + p_26.x))\n        ))))\n       + \n        (fract((sin(tmpvar_25.x) * 43758.55)) * 0.5)\n      ) >= tmpvar_4));\n      color_2.xyz = (color_2.xyz * float((\n        fract(st_19)\n      .y >= 0.2)));\n    };\n  } else {\n    color_2.xyz = vec3(0.0, 0.0, 0.0);\n  };\n  mediump vec4 color_27;\n  color_27 = (color_2 * tmpvar_1);\n  mediump vec4 tmpvar_28;\n  tmpvar_28 = clamp (color_27, 0.0, 1.0);\n  color_27 = tmpvar_28;\n  color_2 = tmpvar_28;\n  gl_FragColor = tmpvar_28;\n}\n\n"
        vertex_shader: "precision highp float;\nuniform mat4 u_model;\nuniform mat4 u_view;\nuniform mat4 u_proj;\nuniform mat3 u_normalMatrix;\nuniform vec3 u_map_position;\nuniform vec3 u_tile_origin;\nattribute vec4 a_position;\nattribute vec4 a_color;\nattribute vec3 a_normal;\nattribute vec2 a_texcoord;\nattribute float a_layer;\nvarying vec4 v_world_position;\nvarying vec4 v_position;\nvarying vec4 v_color;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvarying vec3 v_pos;\nvarying vec3 v_normalModel;\nvoid main ()\n{\n  vec4 position_1;\n  v_color = a_color;\n  v_texcoord = a_texcoord;\n  v_normal = normalize((u_normalMatrix * a_normal));\n  position_1 = (u_model * a_position);\n  vec4 tmpvar_2;\n  tmpvar_2.zw = vec2(0.0, 0.0);\n  tmpvar_2.xy = u_map_position.xy;\n  v_world_position = (position_1 + (vec4(mod (tmpvar_2, 100000.0))));\n  v_pos = (a_position.xyz * 32767.0);\n  v_normalModel = a_normal;\n  position_1.z = (position_1.z * max (1.0, (0.5 + \n    ((1.0 - (u_map_position.z / 20.0)) * 5.0)\n  )));\n  v_position = (u_view * position_1);\n  gl_Position = (u_proj * v_position);\n  gl_Position.z = (gl_Position.z / (1.0 + (0.1 * \n    (abs(u_tile_origin.z) - u_tile_origin.z)\n  )));\n  gl_Position.z = (gl_Position.z - ((a_layer * 1.5e-05) * gl_Position.w));\n}\n\n"
layers:
  earth:
    data: {source: osm}
    draw:
      simple-grid:
        order: 0
        color: [0.362, 0.362, 0.362]
  landuse:
    data: {source: osm}
    draw:
      lines:
        color: [0.703, 0.703, 0.703]
        order: 1
        width: 1px
  water:
    draw:
      numeric-grid:
        order: 3
        color: [1.000, 1.000, 1.000]
      outline:
        width: 2px
        color: [1.000, 1.000, 1.000]
        order: 2
        style: lines
        tile_edges: false
    data: {source: osm}
  roads:
    filter: {not: {kind: rail, highway: service}}
    data: {source: osm}
    draw:
      roads:
        color: [0, 0, 0]
        order: 5
        width: 8
      outline:
        order: 4
        color: [0.773, 0.763, 0.763]
        style: lines
        width: 8.5
    oneway:
      draw: {roads: {color: red}}
      filter: {oneway: yes}
  buildings:
    data: {source: osm}
    draw:
      buildings:
        color: Style.color.pseudoRandomColor()
        order: 7
    3d-buildings:
      draw:
        buildings:
          extrude: true
        buildingsLines:
          order: 8
          color: [0.687, 0.660, 0.660]
          width: .5px
          extrude: true
      filter: {$zoom: {min: 13}}
sources:
  osm:
    type: MVT
    url: https://vector.mapzen.com/osm/all/{z}/{x}/{y}.mvt