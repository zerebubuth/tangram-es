cameras:
  perspective:
    vanishing_point: [0, -500]
    type: perspective
lights:
  directional1:
    origin: world
    direction: [-1, -1, -1]
    type: directional
    ambient: [0.5, 0.5, 0.5, 1.]
    specular: 1.
    diffuse: [.7, .7, .7, 1.]
scene:
  background:
    color: [0., 0.5, 0.8]
styles:
  roads:
    texcoords: true
    base: lines
    lighting: false
    shaders:
      blocks:
        fragment_shader: "precision highp float;\nuniform vec2 u_resolution;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\nvoid main ()\n{\n  highp vec4 color_1;\n  color_1.w = v_color.w;\n  color_1.xyz = vec3((0.14 + ((1.0 - \n    (float((v_texcoord.x >= 0.1)) - float((v_texcoord.x >= 0.9)))\n  ) * 0.1)));\n  highp vec3 background_2;\n  highp vec2 tmpvar_3;\n  tmpvar_3 = ((gl_FragCoord.xy / u_resolution) - vec2(0.5, 0.5));\n  highp vec2 p_4;\n  p_4 = (gl_FragCoord.xy * 0.6);\n  highp float s_5;\n  highp vec2 tmpvar_6;\n  tmpvar_6 = floor(p_4);\n  highp vec2 tmpvar_7;\n  tmpvar_7 = fract(p_4);\n  highp float tmpvar_8;\n  tmpvar_8 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_6.x) + (tmpvar_6.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_6.y * 13.0) + tmpvar_6.x)))\n  )));\n  highp vec2 p_9;\n  p_9 = (tmpvar_6 + vec2(1.0, 0.0));\n  highp float tmpvar_10;\n  tmpvar_10 = fract(((10000.0 * \n    sin(((17.0 * p_9.x) + (p_9.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_9.y * 13.0) + p_9.x)))\n  )));\n  highp vec2 p_11;\n  p_11 = (tmpvar_6 + vec2(0.0, 1.0));\n  highp vec2 p_12;\n  p_12 = (tmpvar_6 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_13;\n  tmpvar_13 = ((tmpvar_7 * tmpvar_7) * (3.0 - (2.0 * tmpvar_7)));\n  s_5 = (0.5 * ((\n    mix (tmpvar_8, tmpvar_10, tmpvar_13.x)\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_11.x)\n       + \n        (p_11.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_11.y * 13.0) + p_11.x)\n      ))))\n    ) - tmpvar_8) * tmpvar_13.y) * (1.0 - tmpvar_13.x))\n  ) + (\n    ((fract((\n      (10000.0 * sin(((17.0 * p_12.x) + (p_12.y * 0.1))))\n     * \n      (0.1 + abs(sin((\n        (p_12.y * 13.0)\n       + p_12.x))))\n    )) - tmpvar_10) * tmpvar_13.x)\n   * tmpvar_13.y)));\n  p_4 = (p_4 * 2.0);\n  highp vec2 tmpvar_14;\n  tmpvar_14 = floor(p_4);\n  highp vec2 tmpvar_15;\n  tmpvar_15 = fract(p_4);\n  highp float tmpvar_16;\n  tmpvar_16 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_14.x) + (tmpvar_14.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_14.y * 13.0) + tmpvar_14.x)))\n  )));\n  highp vec2 p_17;\n  p_17 = (tmpvar_14 + vec2(1.0, 0.0));\n  highp float tmpvar_18;\n  tmpvar_18 = fract(((10000.0 * \n    sin(((17.0 * p_17.x) + (p_17.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_17.y * 13.0) + p_17.x)))\n  )));\n  highp vec2 p_19;\n  p_19 = (tmpvar_14 + vec2(0.0, 1.0));\n  highp vec2 p_20;\n  p_20 = (tmpvar_14 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_21;\n  tmpvar_21 = ((tmpvar_15 * tmpvar_15) * (3.0 - (2.0 * tmpvar_15)));\n  s_5 = (s_5 + (0.25 * (\n    (mix (tmpvar_16, tmpvar_18, tmpvar_21.x) + (((\n      fract(((10000.0 * sin(\n        ((17.0 * p_19.x) + (p_19.y * 0.1))\n      )) * (0.1 + abs(\n        sin(((p_19.y * 13.0) + p_19.x))\n      ))))\n     - tmpvar_16) * tmpvar_21.y) * (1.0 - tmpvar_21.x)))\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_20.x)\n       + \n        (p_20.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_20.y * 13.0) + p_20.x)\n      ))))\n    ) - tmpvar_18) * tmpvar_21.x) * tmpvar_21.y)\n  )));\n  p_4 = (p_4 * 2.0);\n  highp vec3 tmpvar_22;\n  tmpvar_22 = mix (vec3(0.0, 0.5, 0.8), vec3(0.0, 0.0, 0.3), (dot (tmpvar_3, tmpvar_3) + (\n    (s_5 / 0.75)\n   * 0.1)));\n  background_2 = tmpvar_22;\n  bool tmpvar_23;\n  highp vec2 tmpvar_24;\n  tmpvar_24 = fract((gl_FragCoord.xy * 0.01));\n  tmpvar_23 = ((tmpvar_24.x < 0.01) || (tmpvar_24.y < 0.01));\n  if (tmpvar_23) {\n    background_2 = (tmpvar_22 + vec3(0.05, 0.05, 0.05));\n  };\n  bool tmpvar_25;\n  highp vec2 tmpvar_26;\n  tmpvar_26 = fract((gl_FragCoord.xy * 0.1));\n  tmpvar_25 = ((tmpvar_26.x < 0.1) || (tmpvar_26.y < 0.1));\n  if (tmpvar_25) {\n    background_2 = (background_2 + vec3(0.02, 0.02, 0.02));\n  };\n  color_1.xyz = (color_1.xyz + background_2);\n  gl_FragColor = color_1;\n}\n\n"
        vertex_shader: "precision highp float;\nuniform mat4 u_model;\nuniform mat4 u_view;\nuniform mat4 u_proj;\nuniform mat3 u_normalMatrix;\nuniform vec3 u_map_position;\nuniform vec3 u_tile_origin;\nattribute vec4 a_position;\nattribute vec4 a_color;\nattribute vec4 a_extrude;\nattribute vec2 a_texcoord;\nattribute float a_layer;\nvarying vec4 v_world_position;\nvarying vec4 v_position;\nvarying vec4 v_color;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvoid main ()\n{\n  float width_1;\n  vec4 position_2;\n  position_2.zw = a_position.zw;\n  v_color = a_color;\n  v_texcoord = a_texcoord;\n  v_normal = (u_normalMatrix * vec3(0.0, 0.0, 1.0));\n  float tmpvar_3;\n  float tmpvar_4;\n  tmpvar_4 = abs(u_tile_origin.z);\n  tmpvar_3 = (u_map_position.z - tmpvar_4);\n  width_1 = (a_extrude.z + (a_extrude.w * tmpvar_3));\n  width_1 = (width_1 * exp2(-(tmpvar_3)));\n  position_2.xy = (a_position.xy + (a_extrude.xy * width_1));\n  position_2 = (u_model * position_2);\n  vec4 tmpvar_5;\n  tmpvar_5.zw = vec2(0.0, 0.0);\n  tmpvar_5.xy = u_map_position.xy;\n  v_world_position = (position_2 + (vec4(mod (tmpvar_5, 100000.0))));\n  v_position = (u_view * position_2);\n  gl_Position = (u_proj * v_position);\n  gl_Position.z = (gl_Position.z / (1.0 + (0.1 * \n    (tmpvar_4 - u_tile_origin.z)\n  )));\n  gl_Position.z = (gl_Position.z - ((a_layer * 1.5e-05) * gl_Position.w));\n}\n\n"
      defines:
        STYLE: roads
  buildingsLines:
    base: lines
    lighting: false
    shaders:
      blocks:
        fragment_shader: "precision highp float;\nuniform vec3 u_map_position;\nuniform vec2 u_resolution;\nvarying vec4 v_color;\nvoid main ()\n{\n  highp vec4 color_1;\n  color_1 = v_color;\n  highp vec3 background_2;\n  highp vec2 tmpvar_3;\n  tmpvar_3 = ((gl_FragCoord.xy / u_resolution) - vec2(0.5, 0.5));\n  highp vec2 p_4;\n  p_4 = (gl_FragCoord.xy * 0.6);\n  highp float s_5;\n  highp vec2 tmpvar_6;\n  tmpvar_6 = floor(p_4);\n  highp vec2 tmpvar_7;\n  tmpvar_7 = fract(p_4);\n  highp float tmpvar_8;\n  tmpvar_8 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_6.x) + (tmpvar_6.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_6.y * 13.0) + tmpvar_6.x)))\n  )));\n  highp vec2 p_9;\n  p_9 = (tmpvar_6 + vec2(1.0, 0.0));\n  highp float tmpvar_10;\n  tmpvar_10 = fract(((10000.0 * \n    sin(((17.0 * p_9.x) + (p_9.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_9.y * 13.0) + p_9.x)))\n  )));\n  highp vec2 p_11;\n  p_11 = (tmpvar_6 + vec2(0.0, 1.0));\n  highp vec2 p_12;\n  p_12 = (tmpvar_6 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_13;\n  tmpvar_13 = ((tmpvar_7 * tmpvar_7) * (3.0 - (2.0 * tmpvar_7)));\n  s_5 = (0.5 * ((\n    mix (tmpvar_8, tmpvar_10, tmpvar_13.x)\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_11.x)\n       + \n        (p_11.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_11.y * 13.0) + p_11.x)\n      ))))\n    ) - tmpvar_8) * tmpvar_13.y) * (1.0 - tmpvar_13.x))\n  ) + (\n    ((fract((\n      (10000.0 * sin(((17.0 * p_12.x) + (p_12.y * 0.1))))\n     * \n      (0.1 + abs(sin((\n        (p_12.y * 13.0)\n       + p_12.x))))\n    )) - tmpvar_10) * tmpvar_13.x)\n   * tmpvar_13.y)));\n  p_4 = (p_4 * 2.0);\n  highp vec2 tmpvar_14;\n  tmpvar_14 = floor(p_4);\n  highp vec2 tmpvar_15;\n  tmpvar_15 = fract(p_4);\n  highp float tmpvar_16;\n  tmpvar_16 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_14.x) + (tmpvar_14.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_14.y * 13.0) + tmpvar_14.x)))\n  )));\n  highp vec2 p_17;\n  p_17 = (tmpvar_14 + vec2(1.0, 0.0));\n  highp float tmpvar_18;\n  tmpvar_18 = fract(((10000.0 * \n    sin(((17.0 * p_17.x) + (p_17.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_17.y * 13.0) + p_17.x)))\n  )));\n  highp vec2 p_19;\n  p_19 = (tmpvar_14 + vec2(0.0, 1.0));\n  highp vec2 p_20;\n  p_20 = (tmpvar_14 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_21;\n  tmpvar_21 = ((tmpvar_15 * tmpvar_15) * (3.0 - (2.0 * tmpvar_15)));\n  s_5 = (s_5 + (0.25 * (\n    (mix (tmpvar_16, tmpvar_18, tmpvar_21.x) + (((\n      fract(((10000.0 * sin(\n        ((17.0 * p_19.x) + (p_19.y * 0.1))\n      )) * (0.1 + abs(\n        sin(((p_19.y * 13.0) + p_19.x))\n      ))))\n     - tmpvar_16) * tmpvar_21.y) * (1.0 - tmpvar_21.x)))\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_20.x)\n       + \n        (p_20.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_20.y * 13.0) + p_20.x)\n      ))))\n    ) - tmpvar_18) * tmpvar_21.x) * tmpvar_21.y)\n  )));\n  p_4 = (p_4 * 2.0);\n  highp vec3 tmpvar_22;\n  tmpvar_22 = mix (vec3(0.0, 0.5, 0.8), vec3(0.0, 0.0, 0.3), (dot (tmpvar_3, tmpvar_3) + (\n    (s_5 / 0.75)\n   * 0.1)));\n  background_2 = tmpvar_22;\n  bool tmpvar_23;\n  highp vec2 tmpvar_24;\n  tmpvar_24 = fract((gl_FragCoord.xy * 0.01));\n  tmpvar_23 = ((tmpvar_24.x < 0.01) || (tmpvar_24.y < 0.01));\n  if (tmpvar_23) {\n    background_2 = (tmpvar_22 + vec3(0.05, 0.05, 0.05));\n  };\n  bool tmpvar_25;\n  highp vec2 tmpvar_26;\n  tmpvar_26 = fract((gl_FragCoord.xy * 0.1));\n  tmpvar_25 = ((tmpvar_26.x < 0.1) || (tmpvar_26.y < 0.1));\n  if (tmpvar_25) {\n    background_2 = (background_2 + vec3(0.02, 0.02, 0.02));\n  };\n  color_1.xyz = (v_color.xyz + background_2);\n  highp vec3 background_27;\n  highp vec2 tmpvar_28;\n  tmpvar_28 = ((gl_FragCoord.xy / u_resolution) - vec2(0.5, 0.5));\n  highp vec2 p_29;\n  p_29 = (gl_FragCoord.xy * 0.6);\n  highp float s_30;\n  highp vec2 tmpvar_31;\n  tmpvar_31 = floor(p_29);\n  highp vec2 tmpvar_32;\n  tmpvar_32 = fract(p_29);\n  highp float tmpvar_33;\n  tmpvar_33 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_31.x) + (tmpvar_31.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_31.y * 13.0) + tmpvar_31.x)))\n  )));\n  highp vec2 p_34;\n  p_34 = (tmpvar_31 + vec2(1.0, 0.0));\n  highp float tmpvar_35;\n  tmpvar_35 = fract(((10000.0 * \n    sin(((17.0 * p_34.x) + (p_34.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_34.y * 13.0) + p_34.x)))\n  )));\n  highp vec2 p_36;\n  p_36 = (tmpvar_31 + vec2(0.0, 1.0));\n  highp vec2 p_37;\n  p_37 = (tmpvar_31 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_38;\n  tmpvar_38 = ((tmpvar_32 * tmpvar_32) * (3.0 - (2.0 * tmpvar_32)));\n  s_30 = (0.5 * ((\n    mix (tmpvar_33, tmpvar_35, tmpvar_38.x)\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_36.x)\n       + \n        (p_36.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_36.y * 13.0) + p_36.x)\n      ))))\n    ) - tmpvar_33) * tmpvar_38.y) * (1.0 - tmpvar_38.x))\n  ) + (\n    ((fract((\n      (10000.0 * sin(((17.0 * p_37.x) + (p_37.y * 0.1))))\n     * \n      (0.1 + abs(sin((\n        (p_37.y * 13.0)\n       + p_37.x))))\n    )) - tmpvar_35) * tmpvar_38.x)\n   * tmpvar_38.y)));\n  p_29 = (p_29 * 2.0);\n  highp vec2 tmpvar_39;\n  tmpvar_39 = floor(p_29);\n  highp vec2 tmpvar_40;\n  tmpvar_40 = fract(p_29);\n  highp float tmpvar_41;\n  tmpvar_41 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_39.x) + (tmpvar_39.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_39.y * 13.0) + tmpvar_39.x)))\n  )));\n  highp vec2 p_42;\n  p_42 = (tmpvar_39 + vec2(1.0, 0.0));\n  highp float tmpvar_43;\n  tmpvar_43 = fract(((10000.0 * \n    sin(((17.0 * p_42.x) + (p_42.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_42.y * 13.0) + p_42.x)))\n  )));\n  highp vec2 p_44;\n  p_44 = (tmpvar_39 + vec2(0.0, 1.0));\n  highp vec2 p_45;\n  p_45 = (tmpvar_39 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_46;\n  tmpvar_46 = ((tmpvar_40 * tmpvar_40) * (3.0 - (2.0 * tmpvar_40)));\n  s_30 = (s_30 + (0.25 * (\n    (mix (tmpvar_41, tmpvar_43, tmpvar_46.x) + (((\n      fract(((10000.0 * sin(\n        ((17.0 * p_44.x) + (p_44.y * 0.1))\n      )) * (0.1 + abs(\n        sin(((p_44.y * 13.0) + p_44.x))\n      ))))\n     - tmpvar_41) * tmpvar_46.y) * (1.0 - tmpvar_46.x)))\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_45.x)\n       + \n        (p_45.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_45.y * 13.0) + p_45.x)\n      ))))\n    ) - tmpvar_43) * tmpvar_46.x) * tmpvar_46.y)\n  )));\n  p_29 = (p_29 * 2.0);\n  highp vec3 tmpvar_47;\n  tmpvar_47 = mix (vec3(0.0, 0.5, 0.8), vec3(0.0, 0.0, 0.3), (dot (tmpvar_28, tmpvar_28) + (\n    (s_30 / 0.75)\n   * 0.1)));\n  background_27 = tmpvar_47;\n  bool tmpvar_48;\n  highp vec2 tmpvar_49;\n  tmpvar_49 = fract((gl_FragCoord.xy * 0.01));\n  tmpvar_48 = ((tmpvar_49.x < 0.01) || (tmpvar_49.y < 0.01));\n  if (tmpvar_48) {\n    background_27 = (tmpvar_47 + vec3(0.05, 0.05, 0.05));\n  };\n  bool tmpvar_50;\n  highp vec2 tmpvar_51;\n  tmpvar_51 = fract((gl_FragCoord.xy * 0.1));\n  tmpvar_50 = ((tmpvar_51.x < 0.1) || (tmpvar_51.y < 0.1));\n  if (tmpvar_50) {\n    background_27 = (background_27 + vec3(0.02, 0.02, 0.02));\n  };\n  color_1.xyz = mix (background_27, vec3(1.0, 1.0, 1.0), min ((\n    max (0.001, (u_map_position.z - 13.0))\n   / 3.0), 1.0));\n  gl_FragColor = color_1;\n}\n\n"
        vertex_shader: "precision highp float;\nuniform mat4 u_model;\nuniform mat4 u_view;\nuniform mat4 u_proj;\nuniform mat3 u_normalMatrix;\nuniform vec3 u_map_position;\nuniform vec3 u_tile_origin;\nattribute vec4 a_position;\nattribute vec4 a_color;\nattribute vec4 a_extrude;\nattribute vec2 a_texcoord;\nattribute float a_layer;\nvarying vec4 v_world_position;\nvarying vec4 v_position;\nvarying vec4 v_color;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvoid main ()\n{\n  float width_1;\n  vec4 position_2;\n  position_2.zw = a_position.zw;\n  v_color = a_color;\n  v_texcoord = a_texcoord;\n  v_normal = (u_normalMatrix * vec3(0.0, 0.0, 1.0));\n  float tmpvar_3;\n  float tmpvar_4;\n  tmpvar_4 = abs(u_tile_origin.z);\n  tmpvar_3 = (u_map_position.z - tmpvar_4);\n  width_1 = (a_extrude.z + (a_extrude.w * tmpvar_3));\n  width_1 = (width_1 * exp2(-(tmpvar_3)));\n  float tmpvar_5;\n  tmpvar_5 = (a_position.z * 0.006);\n  width_1 = (width_1 * (0.2 + min (\n    (tmpvar_5 * tmpvar_5)\n  , 0.6)));\n  position_2.xy = (a_position.xy + (a_extrude.xy * width_1));\n  position_2 = (u_model * position_2);\n  vec4 tmpvar_6;\n  tmpvar_6.zw = vec2(0.0, 0.0);\n  tmpvar_6.xy = u_map_position.xy;\n  v_world_position = (position_2 + (vec4(mod (tmpvar_6, 100000.0))));\n  v_position = (u_view * position_2);\n  gl_Position = (u_proj * v_position);\n  gl_Position.z = (gl_Position.z / (1.0 + (0.1 * \n    (tmpvar_4 - u_tile_origin.z)\n  )));\n  gl_Position.z = (gl_Position.z - ((a_layer * 1.5e-05) * gl_Position.w));\n}\n\n"
      defines:
        STYLE: buildingsLines
  base:
    base: polygons
    lighting: false
    shaders:
      blocks:
        fragment_shader: "precision highp float;\nuniform vec2 u_resolution;\nvarying vec4 v_color;\nvoid main ()\n{\n  highp vec4 color_1;\n  color_1 = v_color;\n  highp vec3 background_2;\n  highp vec2 tmpvar_3;\n  tmpvar_3 = ((gl_FragCoord.xy / u_resolution) - vec2(0.5, 0.5));\n  highp vec2 p_4;\n  p_4 = (gl_FragCoord.xy * 0.6);\n  highp float s_5;\n  highp vec2 tmpvar_6;\n  tmpvar_6 = floor(p_4);\n  highp vec2 tmpvar_7;\n  tmpvar_7 = fract(p_4);\n  highp float tmpvar_8;\n  tmpvar_8 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_6.x) + (tmpvar_6.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_6.y * 13.0) + tmpvar_6.x)))\n  )));\n  highp vec2 p_9;\n  p_9 = (tmpvar_6 + vec2(1.0, 0.0));\n  highp float tmpvar_10;\n  tmpvar_10 = fract(((10000.0 * \n    sin(((17.0 * p_9.x) + (p_9.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_9.y * 13.0) + p_9.x)))\n  )));\n  highp vec2 p_11;\n  p_11 = (tmpvar_6 + vec2(0.0, 1.0));\n  highp vec2 p_12;\n  p_12 = (tmpvar_6 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_13;\n  tmpvar_13 = ((tmpvar_7 * tmpvar_7) * (3.0 - (2.0 * tmpvar_7)));\n  s_5 = (0.5 * ((\n    mix (tmpvar_8, tmpvar_10, tmpvar_13.x)\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_11.x)\n       + \n        (p_11.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_11.y * 13.0) + p_11.x)\n      ))))\n    ) - tmpvar_8) * tmpvar_13.y) * (1.0 - tmpvar_13.x))\n  ) + (\n    ((fract((\n      (10000.0 * sin(((17.0 * p_12.x) + (p_12.y * 0.1))))\n     * \n      (0.1 + abs(sin((\n        (p_12.y * 13.0)\n       + p_12.x))))\n    )) - tmpvar_10) * tmpvar_13.x)\n   * tmpvar_13.y)));\n  p_4 = (p_4 * 2.0);\n  highp vec2 tmpvar_14;\n  tmpvar_14 = floor(p_4);\n  highp vec2 tmpvar_15;\n  tmpvar_15 = fract(p_4);\n  highp float tmpvar_16;\n  tmpvar_16 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_14.x) + (tmpvar_14.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_14.y * 13.0) + tmpvar_14.x)))\n  )));\n  highp vec2 p_17;\n  p_17 = (tmpvar_14 + vec2(1.0, 0.0));\n  highp float tmpvar_18;\n  tmpvar_18 = fract(((10000.0 * \n    sin(((17.0 * p_17.x) + (p_17.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_17.y * 13.0) + p_17.x)))\n  )));\n  highp vec2 p_19;\n  p_19 = (tmpvar_14 + vec2(0.0, 1.0));\n  highp vec2 p_20;\n  p_20 = (tmpvar_14 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_21;\n  tmpvar_21 = ((tmpvar_15 * tmpvar_15) * (3.0 - (2.0 * tmpvar_15)));\n  s_5 = (s_5 + (0.25 * (\n    (mix (tmpvar_16, tmpvar_18, tmpvar_21.x) + (((\n      fract(((10000.0 * sin(\n        ((17.0 * p_19.x) + (p_19.y * 0.1))\n      )) * (0.1 + abs(\n        sin(((p_19.y * 13.0) + p_19.x))\n      ))))\n     - tmpvar_16) * tmpvar_21.y) * (1.0 - tmpvar_21.x)))\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_20.x)\n       + \n        (p_20.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_20.y * 13.0) + p_20.x)\n      ))))\n    ) - tmpvar_18) * tmpvar_21.x) * tmpvar_21.y)\n  )));\n  p_4 = (p_4 * 2.0);\n  highp vec3 tmpvar_22;\n  tmpvar_22 = mix (vec3(0.0, 0.5, 0.8), vec3(0.0, 0.0, 0.3), (dot (tmpvar_3, tmpvar_3) + (\n    (s_5 / 0.75)\n   * 0.1)));\n  background_2 = tmpvar_22;\n  bool tmpvar_23;\n  highp vec2 tmpvar_24;\n  tmpvar_24 = fract((gl_FragCoord.xy * 0.01));\n  tmpvar_23 = ((tmpvar_24.x < 0.01) || (tmpvar_24.y < 0.01));\n  if (tmpvar_23) {\n    background_2 = (tmpvar_22 + vec3(0.05, 0.05, 0.05));\n  };\n  bool tmpvar_25;\n  highp vec2 tmpvar_26;\n  tmpvar_26 = fract((gl_FragCoord.xy * 0.1));\n  tmpvar_25 = ((tmpvar_26.x < 0.1) || (tmpvar_26.y < 0.1));\n  if (tmpvar_25) {\n    background_2 = (background_2 + vec3(0.02, 0.02, 0.02));\n  };\n  color_1.xyz = (v_color.xyz + background_2);\n  gl_FragColor = color_1;\n}\n\n"
        vertex_shader: "precision highp float;\nuniform mat4 u_model;\nuniform mat4 u_view;\nuniform mat4 u_proj;\nuniform mat3 u_normalMatrix;\nuniform vec3 u_map_position;\nuniform vec3 u_tile_origin;\nattribute vec4 a_position;\nattribute vec4 a_color;\nattribute vec3 a_normal;\nattribute vec2 a_texcoord;\nattribute float a_layer;\nvarying vec4 v_world_position;\nvarying vec4 v_position;\nvarying vec4 v_color;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvoid main ()\n{\n  vec4 position_1;\n  v_color = a_color;\n  v_texcoord = a_texcoord;\n  v_normal = normalize((u_normalMatrix * a_normal));\n  position_1 = (u_model * a_position);\n  vec4 tmpvar_2;\n  tmpvar_2.zw = vec2(0.0, 0.0);\n  tmpvar_2.xy = u_map_position.xy;\n  v_world_position = (position_1 + (vec4(mod (tmpvar_2, 100000.0))));\n  v_position = (u_view * position_1);\n  gl_Position = (u_proj * v_position);\n  gl_Position.z = (gl_Position.z / (1.0 + (0.1 * \n    (abs(u_tile_origin.z) - u_tile_origin.z)\n  )));\n  gl_Position.z = (gl_Position.z - ((a_layer * 1.5e-05) * gl_Position.w));\n}\n\n"
      defines:
        STYLE: base
  blueprint:
    base: polygons
    shaders:
      defines:
        STYLE: blueprint
      blocks:
        vertex_shader: "precision highp float;\nuniform mat4 u_model;\nuniform mat4 u_view;\nuniform mat4 u_proj;\nuniform mat3 u_normalMatrix;\nuniform vec3 u_map_position;\nuniform vec3 u_tile_origin;\nattribute vec4 a_position;\nattribute vec4 a_color;\nattribute vec3 a_normal;\nattribute vec2 a_texcoord;\nattribute float a_layer;\nvarying vec4 v_world_position;\nvarying vec4 v_position;\nvarying vec4 v_color;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvoid main ()\n{\n  vec4 position_1;\n  v_color = a_color;\n  v_texcoord = a_texcoord;\n  v_normal = normalize((u_normalMatrix * a_normal));\n  position_1 = (u_model * a_position);\n  vec4 tmpvar_2;\n  tmpvar_2.zw = vec2(0.0, 0.0);\n  tmpvar_2.xy = u_map_position.xy;\n  v_world_position = (position_1 + (vec4(mod (tmpvar_2, 100000.0))));\n  v_position = (u_view * position_1);\n  gl_Position = (u_proj * v_position);\n  gl_Position.z = (gl_Position.z / (1.0 + (0.1 * \n    (abs(u_tile_origin.z) - u_tile_origin.z)\n  )));\n  gl_Position.z = (gl_Position.z - ((a_layer * 1.5e-05) * gl_Position.w));\n}\n\n"
        fragment_shader: "precision highp float;\nstruct Material {\n  vec4 ambient;\n  vec4 diffuse;\n};\nstruct DirectionalLight {\n  vec4 ambient;\n  vec4 diffuse;\n  vec4 specular;\n  vec3 direction;\n};\nuniform vec2 u_resolution;\nvarying vec4 v_color;\nvarying vec3 v_normal;\nuniform Material u_material;\nuniform DirectionalLight u_directional1;\nvoid main ()\n{\n  highp vec4 color_1;\n  highp vec4 color_2;\n  color_2 = ((u_directional1.ambient * v_color) * u_material.ambient);\n  color_2 = (color_2 + ((\n    (u_directional1.diffuse * clamp (dot (v_normal, -(u_directional1.direction)), 0.0, 1.0))\n   * v_color) * u_material.diffuse));\n  highp vec4 tmpvar_3;\n  tmpvar_3 = clamp (color_2, 0.0, 1.0);\n  color_2 = tmpvar_3;\n  color_1 = tmpvar_3;\n  highp vec3 background_4;\n  highp vec2 tmpvar_5;\n  tmpvar_5 = ((gl_FragCoord.xy / u_resolution) - vec2(0.5, 0.5));\n  highp vec2 p_6;\n  p_6 = (gl_FragCoord.xy * 0.6);\n  highp float s_7;\n  highp vec2 tmpvar_8;\n  tmpvar_8 = floor(p_6);\n  highp vec2 tmpvar_9;\n  tmpvar_9 = fract(p_6);\n  highp float tmpvar_10;\n  tmpvar_10 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_8.x) + (tmpvar_8.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_8.y * 13.0) + tmpvar_8.x)))\n  )));\n  highp vec2 p_11;\n  p_11 = (tmpvar_8 + vec2(1.0, 0.0));\n  highp float tmpvar_12;\n  tmpvar_12 = fract(((10000.0 * \n    sin(((17.0 * p_11.x) + (p_11.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_11.y * 13.0) + p_11.x)))\n  )));\n  highp vec2 p_13;\n  p_13 = (tmpvar_8 + vec2(0.0, 1.0));\n  highp vec2 p_14;\n  p_14 = (tmpvar_8 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_15;\n  tmpvar_15 = ((tmpvar_9 * tmpvar_9) * (3.0 - (2.0 * tmpvar_9)));\n  s_7 = (0.5 * ((\n    mix (tmpvar_10, tmpvar_12, tmpvar_15.x)\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_13.x)\n       + \n        (p_13.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_13.y * 13.0) + p_13.x)\n      ))))\n    ) - tmpvar_10) * tmpvar_15.y) * (1.0 - tmpvar_15.x))\n  ) + (\n    ((fract((\n      (10000.0 * sin(((17.0 * p_14.x) + (p_14.y * 0.1))))\n     * \n      (0.1 + abs(sin((\n        (p_14.y * 13.0)\n       + p_14.x))))\n    )) - tmpvar_12) * tmpvar_15.x)\n   * tmpvar_15.y)));\n  p_6 = (p_6 * 2.0);\n  highp vec2 tmpvar_16;\n  tmpvar_16 = floor(p_6);\n  highp vec2 tmpvar_17;\n  tmpvar_17 = fract(p_6);\n  highp float tmpvar_18;\n  tmpvar_18 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_16.x) + (tmpvar_16.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_16.y * 13.0) + tmpvar_16.x)))\n  )));\n  highp vec2 p_19;\n  p_19 = (tmpvar_16 + vec2(1.0, 0.0));\n  highp float tmpvar_20;\n  tmpvar_20 = fract(((10000.0 * \n    sin(((17.0 * p_19.x) + (p_19.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_19.y * 13.0) + p_19.x)))\n  )));\n  highp vec2 p_21;\n  p_21 = (tmpvar_16 + vec2(0.0, 1.0));\n  highp vec2 p_22;\n  p_22 = (tmpvar_16 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_23;\n  tmpvar_23 = ((tmpvar_17 * tmpvar_17) * (3.0 - (2.0 * tmpvar_17)));\n  s_7 = (s_7 + (0.25 * (\n    (mix (tmpvar_18, tmpvar_20, tmpvar_23.x) + (((\n      fract(((10000.0 * sin(\n        ((17.0 * p_21.x) + (p_21.y * 0.1))\n      )) * (0.1 + abs(\n        sin(((p_21.y * 13.0) + p_21.x))\n      ))))\n     - tmpvar_18) * tmpvar_23.y) * (1.0 - tmpvar_23.x)))\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_22.x)\n       + \n        (p_22.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_22.y * 13.0) + p_22.x)\n      ))))\n    ) - tmpvar_20) * tmpvar_23.x) * tmpvar_23.y)\n  )));\n  p_6 = (p_6 * 2.0);\n  highp vec3 tmpvar_24;\n  tmpvar_24 = mix (vec3(0.0, 0.5, 0.8), vec3(0.0, 0.0, 0.3), (dot (tmpvar_5, tmpvar_5) + (\n    (s_7 / 0.75)\n   * 0.1)));\n  background_4 = tmpvar_24;\n  bool tmpvar_25;\n  highp vec2 tmpvar_26;\n  tmpvar_26 = fract((gl_FragCoord.xy * 0.01));\n  tmpvar_25 = ((tmpvar_26.x < 0.01) || (tmpvar_26.y < 0.01));\n  if (tmpvar_25) {\n    background_4 = (tmpvar_24 + vec3(0.05, 0.05, 0.05));\n  };\n  bool tmpvar_27;\n  highp vec2 tmpvar_28;\n  tmpvar_28 = fract((gl_FragCoord.xy * 0.1));\n  tmpvar_27 = ((tmpvar_28.x < 0.1) || (tmpvar_28.y < 0.1));\n  if (tmpvar_27) {\n    background_4 = (background_4 + vec3(0.02, 0.02, 0.02));\n  };\n  color_1.xyz = (tmpvar_3.xyz + background_4);\n  gl_FragColor = color_1;\n}\n\n"
  buildings:
    lighting: false
    shaders:
      blocks:
        fragment_shader: "precision highp float;\nuniform vec3 u_tile_origin;\nuniform vec2 u_resolution;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\nvarying vec3 v_normalModel;\nvoid main ()\n{\n  highp vec4 color_1;\n  color_1 = v_color;\n  if ((v_normalModel.z == 0.0)) {\n    float tmpvar_2;\n    tmpvar_2 = (0.003 * (u_tile_origin.z / 20.0));\n    color_1.xyz = (1.0 - vec3((float(\n      (v_texcoord.x >= tmpvar_2)\n    ) - float(\n      (v_texcoord.x >= (1.0 - tmpvar_2))\n    ))));\n  };\n  highp vec3 background_3;\n  highp vec2 tmpvar_4;\n  tmpvar_4 = ((gl_FragCoord.xy / u_resolution) - vec2(0.5, 0.5));\n  highp vec2 p_5;\n  p_5 = (gl_FragCoord.xy * 0.6);\n  highp float s_6;\n  highp vec2 tmpvar_7;\n  tmpvar_7 = floor(p_5);\n  highp vec2 tmpvar_8;\n  tmpvar_8 = fract(p_5);\n  highp float tmpvar_9;\n  tmpvar_9 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_7.x) + (tmpvar_7.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_7.y * 13.0) + tmpvar_7.x)))\n  )));\n  highp vec2 p_10;\n  p_10 = (tmpvar_7 + vec2(1.0, 0.0));\n  highp float tmpvar_11;\n  tmpvar_11 = fract(((10000.0 * \n    sin(((17.0 * p_10.x) + (p_10.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_10.y * 13.0) + p_10.x)))\n  )));\n  highp vec2 p_12;\n  p_12 = (tmpvar_7 + vec2(0.0, 1.0));\n  highp vec2 p_13;\n  p_13 = (tmpvar_7 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_14;\n  tmpvar_14 = ((tmpvar_8 * tmpvar_8) * (3.0 - (2.0 * tmpvar_8)));\n  s_6 = (0.5 * ((\n    mix (tmpvar_9, tmpvar_11, tmpvar_14.x)\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_12.x)\n       + \n        (p_12.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_12.y * 13.0) + p_12.x)\n      ))))\n    ) - tmpvar_9) * tmpvar_14.y) * (1.0 - tmpvar_14.x))\n  ) + (\n    ((fract((\n      (10000.0 * sin(((17.0 * p_13.x) + (p_13.y * 0.1))))\n     * \n      (0.1 + abs(sin((\n        (p_13.y * 13.0)\n       + p_13.x))))\n    )) - tmpvar_11) * tmpvar_14.x)\n   * tmpvar_14.y)));\n  p_5 = (p_5 * 2.0);\n  highp vec2 tmpvar_15;\n  tmpvar_15 = floor(p_5);\n  highp vec2 tmpvar_16;\n  tmpvar_16 = fract(p_5);\n  highp float tmpvar_17;\n  tmpvar_17 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_15.x) + (tmpvar_15.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_15.y * 13.0) + tmpvar_15.x)))\n  )));\n  highp vec2 p_18;\n  p_18 = (tmpvar_15 + vec2(1.0, 0.0));\n  highp float tmpvar_19;\n  tmpvar_19 = fract(((10000.0 * \n    sin(((17.0 * p_18.x) + (p_18.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_18.y * 13.0) + p_18.x)))\n  )));\n  highp vec2 p_20;\n  p_20 = (tmpvar_15 + vec2(0.0, 1.0));\n  highp vec2 p_21;\n  p_21 = (tmpvar_15 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_22;\n  tmpvar_22 = ((tmpvar_16 * tmpvar_16) * (3.0 - (2.0 * tmpvar_16)));\n  s_6 = (s_6 + (0.25 * (\n    (mix (tmpvar_17, tmpvar_19, tmpvar_22.x) + (((\n      fract(((10000.0 * sin(\n        ((17.0 * p_20.x) + (p_20.y * 0.1))\n      )) * (0.1 + abs(\n        sin(((p_20.y * 13.0) + p_20.x))\n      ))))\n     - tmpvar_17) * tmpvar_22.y) * (1.0 - tmpvar_22.x)))\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_21.x)\n       + \n        (p_21.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_21.y * 13.0) + p_21.x)\n      ))))\n    ) - tmpvar_19) * tmpvar_22.x) * tmpvar_22.y)\n  )));\n  p_5 = (p_5 * 2.0);\n  highp vec3 tmpvar_23;\n  tmpvar_23 = mix (vec3(0.0, 0.5, 0.8), vec3(0.0, 0.0, 0.3), (dot (tmpvar_4, tmpvar_4) + (\n    (s_6 / 0.75)\n   * 0.1)));\n  background_3 = tmpvar_23;\n  bool tmpvar_24;\n  highp vec2 tmpvar_25;\n  tmpvar_25 = fract((gl_FragCoord.xy * 0.01));\n  tmpvar_24 = ((tmpvar_25.x < 0.01) || (tmpvar_25.y < 0.01));\n  if (tmpvar_24) {\n    background_3 = (tmpvar_23 + vec3(0.05, 0.05, 0.05));\n  };\n  bool tmpvar_26;\n  highp vec2 tmpvar_27;\n  tmpvar_27 = fract((gl_FragCoord.xy * 0.1));\n  tmpvar_26 = ((tmpvar_27.x < 0.1) || (tmpvar_27.y < 0.1));\n  if (tmpvar_26) {\n    background_3 = (background_3 + vec3(0.02, 0.02, 0.02));\n  };\n  color_1.xyz = (color_1.xyz + background_3);\n  gl_FragColor = color_1;\n}\n\n"
        vertex_shader: "precision highp float;\nuniform mat4 u_model;\nuniform mat4 u_view;\nuniform mat4 u_proj;\nuniform mat3 u_normalMatrix;\nuniform vec3 u_map_position;\nuniform vec3 u_tile_origin;\nattribute vec4 a_position;\nattribute vec4 a_color;\nattribute vec3 a_normal;\nattribute vec2 a_texcoord;\nattribute float a_layer;\nvarying vec4 v_world_position;\nvarying vec4 v_position;\nvarying vec4 v_color;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvarying vec3 v_normalModel;\nvoid main ()\n{\n  vec4 position_1;\n  v_color = a_color;\n  v_texcoord = a_texcoord;\n  v_normal = normalize((u_normalMatrix * a_normal));\n  position_1 = (u_model * a_position);\n  vec4 tmpvar_2;\n  tmpvar_2.zw = vec2(0.0, 0.0);\n  tmpvar_2.xy = u_map_position.xy;\n  v_world_position = (position_1 + (vec4(mod (tmpvar_2, 100000.0))));\n  v_normalModel = a_normal;\n  v_position = (u_view * position_1);\n  gl_Position = (u_proj * v_position);\n  gl_Position.z = (gl_Position.z / (1.0 + (0.1 * \n    (abs(u_tile_origin.z) - u_tile_origin.z)\n  )));\n  gl_Position.z = (gl_Position.z - ((a_layer * 1.5e-05) * gl_Position.w));\n}\n\n"
      defines:
        STYLE: buildings
    texcoords: true
    base: polygons
layers:
  water:
    data: {source: osm}
    draw:
      base:
        order: 3
        color: [.1, .1, .1]
  earth:
    data: {source: osm}
    draw:
      base:
        color: [0.080, 0.080, 0.080]
        order: 0
  landuse:
    data: {source: osm}
    draw:
      lines:
        width: 0.5px
        order: 2
        color: white
      base:
        color: [0.116, 0.116, 0.116]
        order: 1
  buildings:
    draw:
      buildings:
        color: [.05, .05, 0.05]
        order: 5
      baseline:
        color: !<!> "#C1D3DC"
        order: 5
        width: [[12, .1], [18, 4.0]]
    filter: {$zoom: {min: 10}}
    data: {source: osm}
    extruded:
      draw:
        buildings:
          extrude: true
        buildingsLines:
          extrude: true
          order: 6
          width: [[12, .1], [14, 0.1], [15, 0.5], [17, 1.0], [18, 1]]
          color: white
      filter: {$zoom: {min: 13}}
  roads:
    draw:
      roads:
        order: 4
        color: !<!> "#C1D3DC"
        width: 6
    data: {source: osm}
    properties: {width: 3}
  road_labels:
    data: {layer: roads, source: osm}
    filter: {railway: false, tunnel: false, name: true, not: {kind: rail}, aeroway: false}
    highway:
      draw:
        text:
          font:
            fill: white
            typeface: 100 16px Helvetica
      filter: {kind: highway, $zoom: {min: 13}}
    not_highway:
      filter: {$zoom: {min: 13}, not: {kind: highway}}
      draw:
        text:
          font:
            typeface: 100 12px Helvetica
            fill: [0.940, 0.958, 0.966]
sources:
  osm:
    url: https://vector.mapzen.com/osm/all/{z}/{x}/{y}.mvt
    type: MVT