cameras:
  camera1:
    focal_length: [[16, 2], [20, 6]]
    type: perspective
    vanishing_point: [-250, -250]
lights:
  directional1:
    specular: 1.
    direction: [-1, -1, -1]
    ambient: [0.3, 0.3, 0.3, 1.]
    type: directional
    origin: world
    diffuse: [.5, .5, .5, 1.]
  point1:
    specular: .4
    position: [0, -100, 0]
    origin: ground
    type: point
    ambient: .2
    diffuse: .5
styles:
  grain:
    base: polygons
    shaders:
      blocks:
        vertex_shader: "precision highp float;\nuniform mat4 u_model;\nuniform mat4 u_modelView;\nuniform mat4 u_modelViewProj;\nuniform mat3 u_normalMatrix;\nuniform vec3 u_tile_origin;\nattribute vec4 a_position;\nattribute vec4 a_color;\nattribute vec3 a_normal;\nattribute vec2 a_texcoord;\nattribute float a_layer;\nvarying vec4 v_color;\nvarying vec3 v_eyeToPoint;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvarying vec4 v_world_position;\nvoid main ()\n{\n  v_color = a_color;\n  v_eyeToPoint = (u_modelView * a_position).xyz;\n  v_normal = normalize((u_normalMatrix * a_normal));\n  v_texcoord = a_texcoord;\n  v_world_position = (u_model * a_position);\n  v_world_position.xy = (v_world_position.xy - (floor(\n    (u_tile_origin / vec3(100000.0, 100000.0, 100000.0))\n  ) * vec3(100000.0, 100000.0, 100000.0)).xy);\n  gl_Position = (u_modelViewProj * a_position);\n  gl_Position.z = (gl_Position.z / (1.0 + (0.1 * \n    (abs(u_tile_origin.z) - u_tile_origin.z)\n  )));\n  gl_Position.z = (gl_Position.z - ((a_layer * 1.5e-05) * gl_Position.w));\n}\n\n"
        fragment_shader: "precision highp float;\nstruct Material {\n  vec4 ambient;\n  vec4 diffuse;\n};\nstruct DirectionalLight {\n  vec4 ambient;\n  vec4 diffuse;\n  vec4 specular;\n  vec3 direction;\n};\nstruct PointLight {\n  vec4 ambient;\n  vec4 diffuse;\n  vec4 specular;\n  vec4 position;\n};\nuniform vec2 u_resolution;\nvarying vec4 v_color;\nvarying vec3 v_eyeToPoint;\nvarying vec3 v_normal;\nuniform Material u_material;\nvec4 light_accumulator_ambient;\nvec4 light_accumulator_diffuse;\nuniform DirectionalLight u_directional1;\nuniform PointLight u_point1;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1 = u_point1.position;\n  highp vec4 color_2;\n  highp vec4 color_3;\n  light_accumulator_ambient = u_directional1.ambient;\n  light_accumulator_diffuse = (u_directional1.diffuse * clamp (dot (v_normal, \n    -(u_directional1.direction)\n  ), 0.0, 1.0));\n  vec3 x_4;\n  x_4 = (tmpvar_1.xyz - v_eyeToPoint);\n  light_accumulator_ambient = (light_accumulator_ambient + u_point1.ambient);\n  light_accumulator_diffuse = (light_accumulator_diffuse + (u_point1.diffuse * clamp (\n    dot (((tmpvar_1.xyz - v_eyeToPoint) / sqrt(dot (x_4, x_4))), v_normal)\n  , 0.0, 1.0)));\n  color_3 = ((light_accumulator_ambient * v_color) * u_material.ambient);\n  color_3 = (color_3 + ((light_accumulator_diffuse * v_color) * u_material.diffuse));\n  highp vec4 tmpvar_5;\n  tmpvar_5 = clamp (color_3, 0.0, 1.0);\n  color_3 = tmpvar_5;\n  color_2.w = tmpvar_5.w;\n  highp vec2 tmpvar_6;\n  tmpvar_6 = ((gl_FragCoord.xy / u_resolution) - vec2(0.5, 0.5));\n  highp vec2 p_7;\n  p_7 = (gl_FragCoord.xy * 0.6);\n  highp float s_8;\n  highp vec2 tmpvar_9;\n  tmpvar_9 = floor(p_7);\n  highp vec2 tmpvar_10;\n  tmpvar_10 = fract(p_7);\n  highp float tmpvar_11;\n  tmpvar_11 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_9.x) + (tmpvar_9.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_9.y * 13.0) + tmpvar_9.x)))\n  )));\n  highp vec2 p_12;\n  p_12 = (tmpvar_9 + vec2(1.0, 0.0));\n  highp float tmpvar_13;\n  tmpvar_13 = fract(((10000.0 * \n    sin(((17.0 * p_12.x) + (p_12.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_12.y * 13.0) + p_12.x)))\n  )));\n  highp vec2 p_14;\n  p_14 = (tmpvar_9 + vec2(0.0, 1.0));\n  highp vec2 p_15;\n  p_15 = (tmpvar_9 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_16;\n  tmpvar_16 = ((tmpvar_10 * tmpvar_10) * (3.0 - (2.0 * tmpvar_10)));\n  s_8 = (0.5 * ((\n    mix (tmpvar_11, tmpvar_13, tmpvar_16.x)\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_14.x)\n       + \n        (p_14.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_14.y * 13.0) + p_14.x)\n      ))))\n    ) - tmpvar_11) * tmpvar_16.y) * (1.0 - tmpvar_16.x))\n  ) + (\n    ((fract((\n      (10000.0 * sin(((17.0 * p_15.x) + (p_15.y * 0.1))))\n     * \n      (0.1 + abs(sin((\n        (p_15.y * 13.0)\n       + p_15.x))))\n    )) - tmpvar_13) * tmpvar_16.x)\n   * tmpvar_16.y)));\n  p_7 = (p_7 * 2.0);\n  highp vec2 tmpvar_17;\n  tmpvar_17 = floor(p_7);\n  highp vec2 tmpvar_18;\n  tmpvar_18 = fract(p_7);\n  highp float tmpvar_19;\n  tmpvar_19 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_17.x) + (tmpvar_17.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_17.y * 13.0) + tmpvar_17.x)))\n  )));\n  highp vec2 p_20;\n  p_20 = (tmpvar_17 + vec2(1.0, 0.0));\n  highp float tmpvar_21;\n  tmpvar_21 = fract(((10000.0 * \n    sin(((17.0 * p_20.x) + (p_20.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_20.y * 13.0) + p_20.x)))\n  )));\n  highp vec2 p_22;\n  p_22 = (tmpvar_17 + vec2(0.0, 1.0));\n  highp vec2 p_23;\n  p_23 = (tmpvar_17 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_24;\n  tmpvar_24 = ((tmpvar_18 * tmpvar_18) * (3.0 - (2.0 * tmpvar_18)));\n  s_8 = (s_8 + (0.25 * (\n    (mix (tmpvar_19, tmpvar_21, tmpvar_24.x) + (((\n      fract(((10000.0 * sin(\n        ((17.0 * p_22.x) + (p_22.y * 0.1))\n      )) * (0.1 + abs(\n        sin(((p_22.y * 13.0) + p_22.x))\n      ))))\n     - tmpvar_19) * tmpvar_24.y) * (1.0 - tmpvar_24.x)))\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_23.x)\n       + \n        (p_23.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_23.y * 13.0) + p_23.x)\n      ))))\n    ) - tmpvar_21) * tmpvar_24.x) * tmpvar_24.y)\n  )));\n  p_7 = (p_7 * 2.0);\n  color_2.xyz = (tmpvar_5.xyz - ((\n    dot (tmpvar_6, tmpvar_6)\n   + \n    ((s_8 / 0.75) * 0.1)\n  ) * 0.3));\n  gl_FragColor = color_2;\n}\n\n"
      defines:
        STYLE: grain
  buildings:
    animated: true
    texcoords: true
    base: polygons
    material:
      specular: 0.0
      shininess: 1.
      emission: 0.0
    shaders:
      blocks:
        vertex_shader: "precision highp float;\nuniform mat4 u_model;\nuniform mat4 u_modelView;\nuniform mat4 u_modelViewProj;\nuniform mat3 u_normalMatrix;\nuniform vec3 u_tile_origin;\nattribute vec4 a_position;\nattribute vec4 a_color;\nattribute vec3 a_normal;\nattribute vec2 a_texcoord;\nattribute float a_layer;\nvarying vec4 v_color;\nvarying vec3 v_eyeToPoint;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvarying vec4 v_world_position;\nvarying vec3 v_normalModel;\nvoid main ()\n{\n  v_normalModel = a_normal;\n  v_color = a_color;\n  v_eyeToPoint = (u_modelView * a_position).xyz;\n  v_normal = normalize((u_normalMatrix * a_normal));\n  v_texcoord = a_texcoord;\n  v_world_position = (u_model * a_position);\n  v_world_position.xy = (v_world_position.xy - (floor(\n    (u_tile_origin / vec3(100000.0, 100000.0, 100000.0))\n  ) * vec3(100000.0, 100000.0, 100000.0)).xy);\n  gl_Position = (u_modelViewProj * a_position);\n  gl_Position.z = (gl_Position.z / (1.0 + (0.1 * \n    (abs(u_tile_origin.z) - u_tile_origin.z)\n  )));\n  gl_Position.z = (gl_Position.z - ((a_layer * 1.5e-05) * gl_Position.w));\n}\n\n"
        fragment_shader: "precision highp float;\nstruct Material {\n  vec4 emission;\n  vec4 ambient;\n  vec4 diffuse;\n  vec4 specular;\n  float shininess;\n};\nstruct DirectionalLight {\n  vec4 ambient;\n  vec4 diffuse;\n  vec4 specular;\n  vec3 direction;\n};\nstruct PointLight {\n  vec4 ambient;\n  vec4 diffuse;\n  vec4 specular;\n  vec4 position;\n};\nuniform vec2 u_resolution;\nuniform float u_time;\nvarying vec4 v_color;\nvarying vec3 v_eyeToPoint;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvarying vec4 v_world_position;\nuniform Material u_material;\nhighp vec4 tmpvar_1;\nvec4 tmpvar_2;\nvec4 light_accumulator_ambient;\nvec4 light_accumulator_diffuse;\nvec4 light_accumulator_specular;\nuniform DirectionalLight u_directional1;\nuniform PointLight u_point1;\nvarying vec3 v_normalModel;\nvoid main ()\n{\n  vec4 tmpvar_3;\n  vec4 tmpvar_4;\n  vec4 tmpvar_5;\n  vec4 tmpvar_6;\n  vec4 tmpvar_7;\n  vec4 tmpvar_8;\n  vec4 tmpvar_9;\n  vec3 tmpvar_10;\n  vec4 tmpvar_11;\n  vec4 tmpvar_12;\n  float tmpvar_13;\n  tmpvar_11 = u_material.ambient;\n  tmpvar_12 = u_material.diffuse;\n  tmpvar_13 = u_material.shininess;\n  tmpvar_1 = u_material.emission;\n  tmpvar_2 = u_material.specular;\n  light_accumulator_ambient = vec4(0.0, 0.0, 0.0, 0.0);\n  light_accumulator_diffuse = vec4(0.0, 0.0, 0.0, 0.0);\n  light_accumulator_specular = vec4(0.0, 0.0, 0.0, 0.0);\n  tmpvar_7 = u_directional1.ambient;\n  tmpvar_8 = u_directional1.diffuse;\n  tmpvar_9 = u_directional1.specular;\n  tmpvar_10 = u_directional1.direction;\n  tmpvar_3 = u_point1.ambient;\n  tmpvar_4 = u_point1.diffuse;\n  tmpvar_5 = u_point1.specular;\n  tmpvar_6 = u_point1.position;\n  highp vec4 color_14;\n  color_14.w = v_color.w;\n  color_14.xyz = (v_color.xyz * vec3(min ((\n    (v_world_position.z * 0.001)\n   + 0.5), 1.0)));\n  float tmpvar_15;\n  tmpvar_15 = fract((u_time * 5e-07));\n  float tmpvar_16;\n  tmpvar_16 = abs(v_normalModel.z);\n  if ((tmpvar_16 == 0.0)) {\n    vec2 tmpvar_17;\n    tmpvar_17.x = (v_texcoord.x * 10.0);\n    tmpvar_17.y = (v_world_position.z * 0.2);\n    vec2 tmpvar_18;\n    tmpvar_18 = floor(tmpvar_17);\n    vec2 tmpvar_19;\n    tmpvar_19 = fract(tmpvar_17);\n    float tmpvar_20;\n    tmpvar_20 = float((tmpvar_19.x >= 0.6));\n    float tmpvar_21;\n    tmpvar_21 = float((tmpvar_19.y >= 0.4));\n    if (((tmpvar_20 * tmpvar_21) > 0.0)) {\n      tmpvar_2 = vec4(max ((1.0 - (\n        (v_world_position.z * 0.001)\n       + 0.5)), 0.0));\n      vec2 p_22;\n      p_22 = ((tmpvar_18 + floor(\n        (v_normal.xy * 10.0)\n      )) + tmpvar_15);\n      tmpvar_1 = (vec4(0.988, 0.983, 0.88, 1.0) * float((\n        fract(((10000.0 * sin(\n          ((17.0 * p_22.x) + (p_22.y * 0.1))\n        )) * (0.1 + abs(\n          sin(((p_22.y * 13.0) + p_22.x))\n        ))))\n       >= 0.5)));\n    };\n  };\n  highp vec4 color_23;\n  float pf_24;\n  light_accumulator_ambient = tmpvar_7;\n  float tmpvar_25;\n  tmpvar_25 = clamp (dot (v_normal, -(tmpvar_10)), 0.0, 1.0);\n  light_accumulator_diffuse = (tmpvar_8 * tmpvar_25);\n  pf_24 = 0.0;\n  if ((tmpvar_25 > 0.0)) {\n    pf_24 = pow (max (dot (\n      normalize(v_eyeToPoint)\n    , \n      (tmpvar_10 - (2.0 * (dot (v_normal, tmpvar_10) * v_normal)))\n    ), 0.0), tmpvar_13);\n  };\n  light_accumulator_specular = (tmpvar_9 * pf_24);\n  float pf_26;\n  vec3 x_27;\n  x_27 = (tmpvar_6.xyz - v_eyeToPoint);\n  vec3 tmpvar_28;\n  tmpvar_28 = ((tmpvar_6.xyz - v_eyeToPoint) / sqrt(dot (x_27, x_27)));\n  float tmpvar_29;\n  tmpvar_29 = clamp (dot (tmpvar_28, v_normal), 0.0, 1.0);\n  light_accumulator_ambient = (tmpvar_7 + tmpvar_3);\n  light_accumulator_diffuse = (light_accumulator_diffuse + (tmpvar_4 * tmpvar_29));\n  pf_26 = 0.0;\n  if ((tmpvar_29 > 0.0)) {\n    vec3 I_30;\n    I_30 = -(tmpvar_28);\n    pf_26 = pow (max (0.0, dot (\n      -(normalize(v_eyeToPoint))\n    , \n      (I_30 - (2.0 * (dot (v_normal, I_30) * v_normal)))\n    )), tmpvar_13);\n  };\n  light_accumulator_specular = (light_accumulator_specular + (tmpvar_5 * pf_26));\n  color_23 = (tmpvar_1 + ((light_accumulator_ambient * color_14) * tmpvar_11));\n  color_23 = (color_23 + ((light_accumulator_diffuse * color_14) * tmpvar_12));\n  color_23 = (color_23 + (light_accumulator_specular * tmpvar_2));\n  highp vec4 tmpvar_31;\n  tmpvar_31 = clamp (color_23, 0.0, 1.0);\n  color_23 = tmpvar_31;\n  color_14.w = tmpvar_31.w;\n  color_14.xyz = (tmpvar_31.xyz + vec3(min ((1.0 - \n    ((v_world_position.z * 0.001) + 0.7)\n  ), 0.5)));\n  highp vec2 tmpvar_32;\n  tmpvar_32 = ((gl_FragCoord.xy / u_resolution) - vec2(0.5, 0.5));\n  highp vec2 p_33;\n  p_33 = (gl_FragCoord.xy * 0.6);\n  highp float s_34;\n  highp vec2 tmpvar_35;\n  tmpvar_35 = floor(p_33);\n  highp vec2 tmpvar_36;\n  tmpvar_36 = fract(p_33);\n  highp float tmpvar_37;\n  tmpvar_37 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_35.x) + (tmpvar_35.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_35.y * 13.0) + tmpvar_35.x)))\n  )));\n  highp vec2 p_38;\n  p_38 = (tmpvar_35 + vec2(1.0, 0.0));\n  highp float tmpvar_39;\n  tmpvar_39 = fract(((10000.0 * \n    sin(((17.0 * p_38.x) + (p_38.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_38.y * 13.0) + p_38.x)))\n  )));\n  highp vec2 p_40;\n  p_40 = (tmpvar_35 + vec2(0.0, 1.0));\n  highp vec2 p_41;\n  p_41 = (tmpvar_35 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_42;\n  tmpvar_42 = ((tmpvar_36 * tmpvar_36) * (3.0 - (2.0 * tmpvar_36)));\n  s_34 = (0.5 * ((\n    mix (tmpvar_37, tmpvar_39, tmpvar_42.x)\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_40.x)\n       + \n        (p_40.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_40.y * 13.0) + p_40.x)\n      ))))\n    ) - tmpvar_37) * tmpvar_42.y) * (1.0 - tmpvar_42.x))\n  ) + (\n    ((fract((\n      (10000.0 * sin(((17.0 * p_41.x) + (p_41.y * 0.1))))\n     * \n      (0.1 + abs(sin((\n        (p_41.y * 13.0)\n       + p_41.x))))\n    )) - tmpvar_39) * tmpvar_42.x)\n   * tmpvar_42.y)));\n  p_33 = (p_33 * 2.0);\n  highp vec2 tmpvar_43;\n  tmpvar_43 = floor(p_33);\n  highp vec2 tmpvar_44;\n  tmpvar_44 = fract(p_33);\n  highp float tmpvar_45;\n  tmpvar_45 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_43.x) + (tmpvar_43.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_43.y * 13.0) + tmpvar_43.x)))\n  )));\n  highp vec2 p_46;\n  p_46 = (tmpvar_43 + vec2(1.0, 0.0));\n  highp float tmpvar_47;\n  tmpvar_47 = fract(((10000.0 * \n    sin(((17.0 * p_46.x) + (p_46.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_46.y * 13.0) + p_46.x)))\n  )));\n  highp vec2 p_48;\n  p_48 = (tmpvar_43 + vec2(0.0, 1.0));\n  highp vec2 p_49;\n  p_49 = (tmpvar_43 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_50;\n  tmpvar_50 = ((tmpvar_44 * tmpvar_44) * (3.0 - (2.0 * tmpvar_44)));\n  s_34 = (s_34 + (0.25 * (\n    (mix (tmpvar_45, tmpvar_47, tmpvar_50.x) + (((\n      fract(((10000.0 * sin(\n        ((17.0 * p_48.x) + (p_48.y * 0.1))\n      )) * (0.1 + abs(\n        sin(((p_48.y * 13.0) + p_48.x))\n      ))))\n     - tmpvar_45) * tmpvar_50.y) * (1.0 - tmpvar_50.x)))\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_49.x)\n       + \n        (p_49.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_49.y * 13.0) + p_49.x)\n      ))))\n    ) - tmpvar_47) * tmpvar_50.x) * tmpvar_50.y)\n  )));\n  p_33 = (p_33 * 2.0);\n  color_14.xyz = (color_14.xyz - (dot (tmpvar_32, tmpvar_32) + (\n    (s_34 / 0.75)\n   * 0.1)));\n  gl_FragColor = color_14;\n}\n\n"
      defines:
        STYLE: buildings
  point:
    shaders:
      blocks:
        fragment_shader: "precision mediump float;\nvarying vec2 v_uv;\nvarying float v_alpha;\nvarying vec4 v_color;\nvoid main ()\n{\n  if ((v_alpha < 1e-05)) {\n    discard;\n  } else {\n    vec2 tmpvar_1;\n    tmpvar_1 = ((v_uv * 2.0) - 1.0);\n    float tmpvar_2;\n    tmpvar_2 = clamp (((\n      sqrt(dot (tmpvar_1, tmpvar_1))\n     - 0.3) / 0.4), 0.0, 1.0);\n    float tmpvar_3;\n    tmpvar_3 = clamp (((\n      sqrt(dot (tmpvar_1, tmpvar_1))\n     - 0.6) / 0.4), 0.0, 1.0);\n    mediump vec4 tmpvar_4;\n    tmpvar_4.xyz = (vec3((1.0 - (tmpvar_2 * \n      (tmpvar_2 * (3.0 - (2.0 * tmpvar_2)))\n    ))) * v_color.xyz);\n    tmpvar_4.w = (((1.0 - \n      (tmpvar_3 * (tmpvar_3 * (3.0 - (2.0 * tmpvar_3))))\n    ) * v_alpha) * v_color.w);\n    gl_FragColor = tmpvar_4;\n  };\n}\n\n"
        vertex_shader: "precision mediump float;\nattribute lowp vec2 a_position;\nattribute lowp vec2 a_screenPosition;\nattribute vec2 a_uv;\nattribute lowp float a_alpha;\nattribute lowp float a_rotation;\nattribute lowp vec4 a_color;\nattribute lowp vec4 a_stroke;\nuniform mat4 u_proj;\nvarying vec2 v_uv;\nvarying lowp float v_alpha;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_strokeColor;\nvarying lowp float v_strokeWidth;\nvoid main ()\n{\n  if ((a_alpha > 1e-05)) {\n    lowp float tmpvar_1;\n    tmpvar_1 = sin(a_rotation);\n    lowp float tmpvar_2;\n    tmpvar_2 = cos(a_rotation);\n    lowp vec4 tmpvar_3;\n    tmpvar_3.zw = vec2(0.0, 1.0);\n    tmpvar_3.x = (((a_position.x * tmpvar_2) - (a_position.y * tmpvar_1)) + a_screenPosition.x);\n    tmpvar_3.y = (((a_position.x * tmpvar_1) + (a_position.y * tmpvar_2)) + a_screenPosition.y);\n    gl_Position = (u_proj * tmpvar_3);\n  } else {\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n  };\n  v_alpha = a_alpha;\n  v_uv = a_uv;\n  v_color = a_color;\n  v_strokeWidth = a_stroke.w;\n  lowp vec3 tmpvar_4;\n  if ((a_stroke.w > 1e-05)) {\n    tmpvar_4 = a_stroke.xyz;\n  } else {\n    tmpvar_4 = a_color.xyz;\n  };\n  v_strokeColor.xyz = tmpvar_4;\n}\n\n"
  roads:
    texcoords: true
    base: lines
    material:
      diffuse: .9
      emission: 0.0
    shaders:
      blocks:
        vertex_shader: "precision highp float;\nuniform mat4 u_model;\nuniform mat4 u_modelView;\nuniform mat4 u_modelViewProj;\nuniform mat3 u_normalMatrix;\nuniform vec3 u_map_position;\nuniform vec3 u_tile_origin;\nattribute vec4 a_position;\nattribute vec4 a_color;\nattribute vec4 a_extrude;\nattribute vec2 a_texcoord;\nattribute float a_layer;\nvarying vec4 v_world_position;\nvarying vec4 v_color;\nvarying vec3 v_eyeToPoint;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvoid main ()\n{\n  float width_1;\n  vec4 position_2;\n  position_2.zw = a_position.zw;\n  float tmpvar_3;\n  float tmpvar_4;\n  tmpvar_4 = abs(u_tile_origin.z);\n  tmpvar_3 = (u_map_position.z - tmpvar_4);\n  width_1 = (a_extrude.z + (a_extrude.w * tmpvar_3));\n  width_1 = (width_1 * exp2(-(tmpvar_3)));\n  position_2.xy = (a_position.xy + (a_extrude.xy * width_1));\n  v_color = a_color;\n  v_eyeToPoint = (u_modelView * a_position).xyz;\n  v_normal = (u_normalMatrix * vec3(0.0, 0.0, 1.0));\n  v_texcoord = a_texcoord;\n  v_world_position = (u_model * position_2);\n  v_world_position.xy = (v_world_position.xy - (floor(\n    (u_tile_origin / vec3(100000.0, 100000.0, 100000.0))\n  ) * vec3(100000.0, 100000.0, 100000.0)).xy);\n  gl_Position = (u_modelViewProj * position_2);\n  gl_Position.z = (gl_Position.z / (1.0 + (0.1 * \n    (tmpvar_4 - u_tile_origin.z)\n  )));\n  gl_Position.z = (gl_Position.z - ((a_layer * 1.5e-05) * gl_Position.w));\n}\n\n"
        fragment_shader: "precision highp float;\nstruct Material {\n  vec4 emission;\n  vec4 ambient;\n  vec4 diffuse;\n};\nstruct DirectionalLight {\n  vec4 ambient;\n  vec4 diffuse;\n  vec4 specular;\n  vec3 direction;\n};\nstruct PointLight {\n  vec4 ambient;\n  vec4 diffuse;\n  vec4 specular;\n  vec4 position;\n};\nuniform vec2 u_resolution;\nuniform float u_time;\nvarying vec4 v_color;\nvarying vec3 v_eyeToPoint;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvarying vec4 v_world_position;\nuniform Material u_material;\nhighp vec4 tmpvar_1;\nvec4 light_accumulator_ambient;\nvec4 light_accumulator_diffuse;\nuniform DirectionalLight u_directional1;\nuniform PointLight u_point1;\nvoid main ()\n{\n  vec4 tmpvar_2;\n  vec4 tmpvar_3;\n  vec4 tmpvar_4;\n  vec4 tmpvar_5;\n  vec4 tmpvar_6;\n  vec3 tmpvar_7;\n  vec4 tmpvar_8;\n  vec4 tmpvar_9;\n  tmpvar_8 = u_material.ambient;\n  tmpvar_9 = u_material.diffuse;\n  tmpvar_1 = u_material.emission;\n  light_accumulator_ambient = vec4(0.0, 0.0, 0.0, 0.0);\n  light_accumulator_diffuse = vec4(0.0, 0.0, 0.0, 0.0);\n  tmpvar_5 = u_directional1.ambient;\n  tmpvar_6 = u_directional1.diffuse;\n  tmpvar_7 = u_directional1.direction;\n  tmpvar_2 = u_point1.ambient;\n  tmpvar_3 = u_point1.diffuse;\n  tmpvar_4 = u_point1.position;\n  vec2 fpos_10;\n  vec2 st_11;\n  highp vec4 color_12;\n  color_12 = v_color;\n  st_11 = v_texcoord;\n  if ((v_color.x < 0.5)) {\n    if ((v_texcoord.x < 0.5)) {\n      st_11.y = (1.0 - v_texcoord.y);\n    };\n    st_11.x = fract((v_texcoord.x * 2.0));\n  };\n  st_11 = (st_11 * vec2(4.0, 1.0));\n  st_11 = (st_11 + vec2(1.0, 1.0));\n  vec2 tmpvar_13;\n  tmpvar_13.x = 0.0;\n  tmpvar_13.y = ((u_time * -0.1) * fract((\n    sin(floor(st_11).x)\n   * 43758.55)));\n  fpos_10 = (fract(st_11) + tmpvar_13);\n  vec2 tmpvar_14;\n  tmpvar_14 = floor((fpos_10 * vec2(10.0, 10.0)));\n  vec2 tmpvar_15;\n  tmpvar_15 = fract((fpos_10 * vec2(1.0, 10.0)));\n  fpos_10 = tmpvar_15;\n  st_11 = (v_world_position.xy * 0.04);\n  vec2 tmpvar_16;\n  tmpvar_16 = floor(st_11);\n  vec2 tmpvar_17;\n  tmpvar_17 = fract(st_11);\n  float tmpvar_18;\n  tmpvar_18 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_16.x) + (tmpvar_16.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_16.y * 13.0) + tmpvar_16.x)))\n  )));\n  vec2 p_19;\n  p_19 = (tmpvar_16 + vec2(1.0, 0.0));\n  float tmpvar_20;\n  tmpvar_20 = fract(((10000.0 * \n    sin(((17.0 * p_19.x) + (p_19.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_19.y * 13.0) + p_19.x)))\n  )));\n  vec2 p_21;\n  p_21 = (tmpvar_16 + vec2(0.0, 1.0));\n  vec2 p_22;\n  p_22 = (tmpvar_16 + vec2(1.0, 1.0));\n  vec2 tmpvar_23;\n  tmpvar_23 = ((tmpvar_17 * tmpvar_17) * (3.0 - (2.0 * tmpvar_17)));\n  tmpvar_1 = (vec4(0.957, 0.988, 0.976, 1.0) * max (0.0, (\n    (0.7 - (dot ((tmpvar_15 - 0.5), (tmpvar_15 - vec2(0.5, 0.9))) * 3.0))\n   * \n    float((fract((\n      sin(tmpvar_14.y)\n     * 43758.55)) >= 0.5))\n  )));\n  float tmpvar_24;\n  tmpvar_24 = (1.0 - (float(\n    (v_texcoord.x >= 0.2)\n  ) - float(\n    (v_texcoord.x >= 0.8)\n  )));\n  tmpvar_1 = (tmpvar_1 * (1.0 - tmpvar_24));\n  color_12.xyz = ((vec3(0.4, 0.4, 0.4) * tmpvar_24) + ((\n    mix (tmpvar_18, tmpvar_20, tmpvar_23.x)\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_21.x)\n       + \n        (p_21.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_21.y * 13.0) + p_21.x)\n      ))))\n    ) - tmpvar_18) * tmpvar_23.y) * (1.0 - tmpvar_23.x))\n  ) + (\n    ((fract((\n      (10000.0 * sin(((17.0 * p_22.x) + (p_22.y * 0.1))))\n     * \n      (0.1 + abs(sin((\n        (p_22.y * 13.0)\n       + p_22.x))))\n    )) - tmpvar_20) * tmpvar_23.x)\n   * tmpvar_23.y)));\n  highp vec4 color_25;\n  light_accumulator_diffuse = (tmpvar_6 * clamp (dot (v_normal, \n    -(tmpvar_7)\n  ), 0.0, 1.0));\n  vec3 x_26;\n  x_26 = (tmpvar_4.xyz - v_eyeToPoint);\n  light_accumulator_ambient = (tmpvar_5 + tmpvar_2);\n  light_accumulator_diffuse = (light_accumulator_diffuse + (tmpvar_3 * clamp (\n    dot (((tmpvar_4.xyz - v_eyeToPoint) / sqrt(dot (x_26, x_26))), v_normal)\n  , 0.0, 1.0)));\n  color_25 = (tmpvar_1 + ((light_accumulator_ambient * color_12) * tmpvar_8));\n  color_25 = (color_25 + ((light_accumulator_diffuse * color_12) * tmpvar_9));\n  highp vec4 tmpvar_27;\n  tmpvar_27 = clamp (color_25, 0.0, 1.0);\n  color_25 = tmpvar_27;\n  color_12.w = tmpvar_27.w;\n  highp vec2 tmpvar_28;\n  tmpvar_28 = ((gl_FragCoord.xy / u_resolution) - vec2(0.5, 0.5));\n  highp vec2 p_29;\n  p_29 = (gl_FragCoord.xy * 0.6);\n  highp float s_30;\n  highp vec2 tmpvar_31;\n  tmpvar_31 = floor(p_29);\n  highp vec2 tmpvar_32;\n  tmpvar_32 = fract(p_29);\n  highp float tmpvar_33;\n  tmpvar_33 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_31.x) + (tmpvar_31.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_31.y * 13.0) + tmpvar_31.x)))\n  )));\n  highp vec2 p_34;\n  p_34 = (tmpvar_31 + vec2(1.0, 0.0));\n  highp float tmpvar_35;\n  tmpvar_35 = fract(((10000.0 * \n    sin(((17.0 * p_34.x) + (p_34.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_34.y * 13.0) + p_34.x)))\n  )));\n  highp vec2 p_36;\n  p_36 = (tmpvar_31 + vec2(0.0, 1.0));\n  highp vec2 p_37;\n  p_37 = (tmpvar_31 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_38;\n  tmpvar_38 = ((tmpvar_32 * tmpvar_32) * (3.0 - (2.0 * tmpvar_32)));\n  s_30 = (0.5 * ((\n    mix (tmpvar_33, tmpvar_35, tmpvar_38.x)\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_36.x)\n       + \n        (p_36.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_36.y * 13.0) + p_36.x)\n      ))))\n    ) - tmpvar_33) * tmpvar_38.y) * (1.0 - tmpvar_38.x))\n  ) + (\n    ((fract((\n      (10000.0 * sin(((17.0 * p_37.x) + (p_37.y * 0.1))))\n     * \n      (0.1 + abs(sin((\n        (p_37.y * 13.0)\n       + p_37.x))))\n    )) - tmpvar_35) * tmpvar_38.x)\n   * tmpvar_38.y)));\n  p_29 = (p_29 * 2.0);\n  highp vec2 tmpvar_39;\n  tmpvar_39 = floor(p_29);\n  highp vec2 tmpvar_40;\n  tmpvar_40 = fract(p_29);\n  highp float tmpvar_41;\n  tmpvar_41 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_39.x) + (tmpvar_39.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_39.y * 13.0) + tmpvar_39.x)))\n  )));\n  highp vec2 p_42;\n  p_42 = (tmpvar_39 + vec2(1.0, 0.0));\n  highp float tmpvar_43;\n  tmpvar_43 = fract(((10000.0 * \n    sin(((17.0 * p_42.x) + (p_42.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_42.y * 13.0) + p_42.x)))\n  )));\n  highp vec2 p_44;\n  p_44 = (tmpvar_39 + vec2(0.0, 1.0));\n  highp vec2 p_45;\n  p_45 = (tmpvar_39 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_46;\n  tmpvar_46 = ((tmpvar_40 * tmpvar_40) * (3.0 - (2.0 * tmpvar_40)));\n  s_30 = (s_30 + (0.25 * (\n    (mix (tmpvar_41, tmpvar_43, tmpvar_46.x) + (((\n      fract(((10000.0 * sin(\n        ((17.0 * p_44.x) + (p_44.y * 0.1))\n      )) * (0.1 + abs(\n        sin(((p_44.y * 13.0) + p_44.x))\n      ))))\n     - tmpvar_41) * tmpvar_46.y) * (1.0 - tmpvar_46.x)))\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_45.x)\n       + \n        (p_45.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_45.y * 13.0) + p_45.x)\n      ))))\n    ) - tmpvar_43) * tmpvar_46.x) * tmpvar_46.y)\n  )));\n  p_29 = (p_29 * 2.0);\n  color_12.xyz = (tmpvar_27.xyz - (dot (tmpvar_28, tmpvar_28) + (\n    (s_30 / 0.75)\n   * 0.1)));\n  gl_FragColor = color_12;\n}\n\n"
      defines:
        STYLE: roads
  modern-buildings:
    material:
      specular: 1.0
      shininess: 1.
      emission: 0.0
    shaders:
      blocks:
        vertex_shader: "precision highp float;\nuniform mat4 u_model;\nuniform mat4 u_modelView;\nuniform mat4 u_modelViewProj;\nuniform mat3 u_normalMatrix;\nuniform vec3 u_tile_origin;\nattribute vec4 a_position;\nattribute vec4 a_color;\nattribute vec3 a_normal;\nattribute vec2 a_texcoord;\nattribute float a_layer;\nvarying vec4 v_color;\nvarying vec3 v_eyeToPoint;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvarying vec4 v_world_position;\nvarying vec3 v_normalModel;\nvoid main ()\n{\n  v_normalModel = a_normal;\n  v_color = a_color;\n  v_eyeToPoint = (u_modelView * a_position).xyz;\n  v_normal = normalize((u_normalMatrix * a_normal));\n  v_texcoord = a_texcoord;\n  v_world_position = (u_model * a_position);\n  v_world_position.xy = (v_world_position.xy - (floor(\n    (u_tile_origin / vec3(100000.0, 100000.0, 100000.0))\n  ) * vec3(100000.0, 100000.0, 100000.0)).xy);\n  gl_Position = (u_modelViewProj * a_position);\n  gl_Position.z = (gl_Position.z / (1.0 + (0.1 * \n    (abs(u_tile_origin.z) - u_tile_origin.z)\n  )));\n  gl_Position.z = (gl_Position.z - ((a_layer * 1.5e-05) * gl_Position.w));\n}\n\n"
        fragment_shader: "precision highp float;\nstruct Material {\n  vec4 emission;\n  vec4 ambient;\n  vec4 diffuse;\n  vec4 specular;\n  float shininess;\n};\nstruct DirectionalLight {\n  vec4 ambient;\n  vec4 diffuse;\n  vec4 specular;\n  vec3 direction;\n};\nstruct PointLight {\n  vec4 ambient;\n  vec4 diffuse;\n  vec4 specular;\n  vec4 position;\n};\nuniform vec2 u_resolution;\nvarying vec4 v_color;\nvarying vec3 v_eyeToPoint;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvarying vec4 v_world_position;\nuniform Material u_material;\nhighp vec4 tmpvar_1;\nvec4 tmpvar_2;\nvec4 light_accumulator_ambient;\nvec4 light_accumulator_diffuse;\nvec4 light_accumulator_specular;\nuniform DirectionalLight u_directional1;\nuniform PointLight u_point1;\nvarying vec3 v_normalModel;\nvoid main ()\n{\n  vec4 tmpvar_3;\n  vec4 tmpvar_4;\n  vec4 tmpvar_5;\n  vec4 tmpvar_6;\n  vec4 tmpvar_7;\n  vec4 tmpvar_8;\n  vec4 tmpvar_9;\n  vec3 tmpvar_10;\n  vec4 tmpvar_11;\n  vec4 tmpvar_12;\n  float tmpvar_13;\n  tmpvar_11 = u_material.ambient;\n  tmpvar_12 = u_material.diffuse;\n  tmpvar_13 = u_material.shininess;\n  tmpvar_1 = u_material.emission;\n  tmpvar_2 = u_material.specular;\n  light_accumulator_ambient = vec4(0.0, 0.0, 0.0, 0.0);\n  light_accumulator_diffuse = vec4(0.0, 0.0, 0.0, 0.0);\n  light_accumulator_specular = vec4(0.0, 0.0, 0.0, 0.0);\n  tmpvar_7 = u_directional1.ambient;\n  tmpvar_8 = u_directional1.diffuse;\n  tmpvar_9 = u_directional1.specular;\n  tmpvar_10 = u_directional1.direction;\n  tmpvar_3 = u_point1.ambient;\n  tmpvar_4 = u_point1.diffuse;\n  tmpvar_5 = u_point1.specular;\n  tmpvar_6 = u_point1.position;\n  highp vec4 color_14;\n  color_14.w = v_color.w;\n  color_14.xyz = (v_color.xyz * vec3(min ((\n    (v_world_position.z * 0.001)\n   + 0.5), 1.0)));\n  if ((v_normalModel.z == 0.0)) {\n    vec3 col_15;\n    vec2 tmpvar_16;\n    tmpvar_16.x = (v_texcoord.x * 10.0);\n    tmpvar_16.y = (v_world_position.z * 0.2);\n    vec2 st_17;\n    st_17 = (tmpvar_16 * 0.8);\n    vec3 m_19;\n    vec2 fpos_20;\n    vec2 ipos_21;\n    ipos_21 = floor(st_17);\n    fpos_20 = fract(st_17);\n    m_19 = vec3(8.0, 8.0, 8.0);\n    for (highp int j_18 = -1; j_18 <= 1; j_18++) {\n      vec2 tmpvar_22;\n      tmpvar_22.x = -1.0;\n      tmpvar_22.y = float(j_18);\n      vec2 p_23;\n      p_23 = (ipos_21 + tmpvar_22);\n      vec2 tmpvar_24;\n      tmpvar_24.x = dot (p_23, vec2(127.1, 311.7));\n      tmpvar_24.y = dot (p_23, vec2(269.5, 183.3));\n      p_23 = tmpvar_24;\n      vec2 tmpvar_25;\n      tmpvar_25 = fract((sin(tmpvar_24) * 18.5453));\n      vec2 tmpvar_26;\n      tmpvar_26 = ((tmpvar_22 - fpos_20) + tmpvar_25);\n      float tmpvar_27;\n      tmpvar_27 = dot (tmpvar_26, tmpvar_26);\n      if ((tmpvar_27 < m_19.x)) {\n        vec3 tmpvar_28;\n        tmpvar_28.x = tmpvar_27;\n        tmpvar_28.yz = tmpvar_25;\n        m_19 = tmpvar_28;\n      };\n      vec2 tmpvar_29;\n      tmpvar_29.x = 0.0;\n      tmpvar_29.y = float(j_18);\n      vec2 p_30;\n      p_30 = (ipos_21 + tmpvar_29);\n      vec2 tmpvar_31;\n      tmpvar_31.x = dot (p_30, vec2(127.1, 311.7));\n      tmpvar_31.y = dot (p_30, vec2(269.5, 183.3));\n      p_30 = tmpvar_31;\n      vec2 tmpvar_32;\n      tmpvar_32 = fract((sin(tmpvar_31) * 18.5453));\n      vec2 tmpvar_33;\n      tmpvar_33 = ((tmpvar_29 - fpos_20) + tmpvar_32);\n      float tmpvar_34;\n      tmpvar_34 = dot (tmpvar_33, tmpvar_33);\n      if ((tmpvar_34 < m_19.x)) {\n        vec3 tmpvar_35;\n        tmpvar_35.x = tmpvar_34;\n        tmpvar_35.yz = tmpvar_32;\n        m_19 = tmpvar_35;\n      };\n      vec2 tmpvar_36;\n      tmpvar_36.x = 1.0;\n      tmpvar_36.y = float(j_18);\n      vec2 p_37;\n      p_37 = (ipos_21 + tmpvar_36);\n      vec2 tmpvar_38;\n      tmpvar_38.x = dot (p_37, vec2(127.1, 311.7));\n      tmpvar_38.y = dot (p_37, vec2(269.5, 183.3));\n      p_37 = tmpvar_38;\n      vec2 tmpvar_39;\n      tmpvar_39 = fract((sin(tmpvar_38) * 18.5453));\n      vec2 tmpvar_40;\n      tmpvar_40 = ((tmpvar_36 - fpos_20) + tmpvar_39);\n      float tmpvar_41;\n      tmpvar_41 = dot (tmpvar_40, tmpvar_40);\n      if ((tmpvar_41 < m_19.x)) {\n        vec3 tmpvar_42;\n        tmpvar_42.x = tmpvar_41;\n        tmpvar_42.yz = tmpvar_39;\n        m_19 = tmpvar_42;\n      };\n    };\n    vec3 tmpvar_43;\n    tmpvar_43 = (0.6 + cos((\n      (m_19.y * 0.6)\n     + vec3(1.5, 1.5, 1.5))));\n    col_15 = tmpvar_43;\n    vec2 st_44;\n    st_44 = (0.8 * (tmpvar_16 + vec2(0.04, 0.0)));\n    vec3 m_46;\n    vec2 fpos_47;\n    vec2 ipos_48;\n    ipos_48 = floor(st_44);\n    fpos_47 = fract(st_44);\n    m_46 = vec3(8.0, 8.0, 8.0);\n    for (highp int j_45 = -1; j_45 <= 1; j_45++) {\n      vec2 tmpvar_49;\n      tmpvar_49.x = -1.0;\n      tmpvar_49.y = float(j_45);\n      vec2 p_50;\n      p_50 = (ipos_48 + tmpvar_49);\n      vec2 tmpvar_51;\n      tmpvar_51.x = dot (p_50, vec2(127.1, 311.7));\n      tmpvar_51.y = dot (p_50, vec2(269.5, 183.3));\n      p_50 = tmpvar_51;\n      vec2 tmpvar_52;\n      tmpvar_52 = fract((sin(tmpvar_51) * 18.5453));\n      vec2 tmpvar_53;\n      tmpvar_53 = ((tmpvar_49 - fpos_47) + tmpvar_52);\n      float tmpvar_54;\n      tmpvar_54 = dot (tmpvar_53, tmpvar_53);\n      if ((tmpvar_54 < m_46.x)) {\n        vec3 tmpvar_55;\n        tmpvar_55.x = tmpvar_54;\n        tmpvar_55.yz = tmpvar_52;\n        m_46 = tmpvar_55;\n      };\n      vec2 tmpvar_56;\n      tmpvar_56.x = 0.0;\n      tmpvar_56.y = float(j_45);\n      vec2 p_57;\n      p_57 = (ipos_48 + tmpvar_56);\n      vec2 tmpvar_58;\n      tmpvar_58.x = dot (p_57, vec2(127.1, 311.7));\n      tmpvar_58.y = dot (p_57, vec2(269.5, 183.3));\n      p_57 = tmpvar_58;\n      vec2 tmpvar_59;\n      tmpvar_59 = fract((sin(tmpvar_58) * 18.5453));\n      vec2 tmpvar_60;\n      tmpvar_60 = ((tmpvar_56 - fpos_47) + tmpvar_59);\n      float tmpvar_61;\n      tmpvar_61 = dot (tmpvar_60, tmpvar_60);\n      if ((tmpvar_61 < m_46.x)) {\n        vec3 tmpvar_62;\n        tmpvar_62.x = tmpvar_61;\n        tmpvar_62.yz = tmpvar_59;\n        m_46 = tmpvar_62;\n      };\n      vec2 tmpvar_63;\n      tmpvar_63.x = 1.0;\n      tmpvar_63.y = float(j_45);\n      vec2 p_64;\n      p_64 = (ipos_48 + tmpvar_63);\n      vec2 tmpvar_65;\n      tmpvar_65.x = dot (p_64, vec2(127.1, 311.7));\n      tmpvar_65.y = dot (p_64, vec2(269.5, 183.3));\n      p_64 = tmpvar_65;\n      vec2 tmpvar_66;\n      tmpvar_66 = fract((sin(tmpvar_65) * 18.5453));\n      vec2 tmpvar_67;\n      tmpvar_67 = ((tmpvar_63 - fpos_47) + tmpvar_66);\n      float tmpvar_68;\n      tmpvar_68 = dot (tmpvar_67, tmpvar_67);\n      if ((tmpvar_68 < m_46.x)) {\n        vec3 tmpvar_69;\n        tmpvar_69.x = tmpvar_68;\n        tmpvar_69.yz = tmpvar_66;\n        m_46 = tmpvar_69;\n      };\n    };\n    vec2 st_70;\n    st_70 = (0.8 * (tmpvar_16 + vec2(0.0, 0.04)));\n    vec3 m_72;\n    vec2 fpos_73;\n    vec2 ipos_74;\n    ipos_74 = floor(st_70);\n    fpos_73 = fract(st_70);\n    m_72 = vec3(8.0, 8.0, 8.0);\n    for (highp int j_71 = -1; j_71 <= 1; j_71++) {\n      vec2 tmpvar_75;\n      tmpvar_75.x = -1.0;\n      tmpvar_75.y = float(j_71);\n      vec2 p_76;\n      p_76 = (ipos_74 + tmpvar_75);\n      vec2 tmpvar_77;\n      tmpvar_77.x = dot (p_76, vec2(127.1, 311.7));\n      tmpvar_77.y = dot (p_76, vec2(269.5, 183.3));\n      p_76 = tmpvar_77;\n      vec2 tmpvar_78;\n      tmpvar_78 = fract((sin(tmpvar_77) * 18.5453));\n      vec2 tmpvar_79;\n      tmpvar_79 = ((tmpvar_75 - fpos_73) + tmpvar_78);\n      float tmpvar_80;\n      tmpvar_80 = dot (tmpvar_79, tmpvar_79);\n      if ((tmpvar_80 < m_72.x)) {\n        vec3 tmpvar_81;\n        tmpvar_81.x = tmpvar_80;\n        tmpvar_81.yz = tmpvar_78;\n        m_72 = tmpvar_81;\n      };\n      vec2 tmpvar_82;\n      tmpvar_82.x = 0.0;\n      tmpvar_82.y = float(j_71);\n      vec2 p_83;\n      p_83 = (ipos_74 + tmpvar_82);\n      vec2 tmpvar_84;\n      tmpvar_84.x = dot (p_83, vec2(127.1, 311.7));\n      tmpvar_84.y = dot (p_83, vec2(269.5, 183.3));\n      p_83 = tmpvar_84;\n      vec2 tmpvar_85;\n      tmpvar_85 = fract((sin(tmpvar_84) * 18.5453));\n      vec2 tmpvar_86;\n      tmpvar_86 = ((tmpvar_82 - fpos_73) + tmpvar_85);\n      float tmpvar_87;\n      tmpvar_87 = dot (tmpvar_86, tmpvar_86);\n      if ((tmpvar_87 < m_72.x)) {\n        vec3 tmpvar_88;\n        tmpvar_88.x = tmpvar_87;\n        tmpvar_88.yz = tmpvar_85;\n        m_72 = tmpvar_88;\n      };\n      vec2 tmpvar_89;\n      tmpvar_89.x = 1.0;\n      tmpvar_89.y = float(j_71);\n      vec2 p_90;\n      p_90 = (ipos_74 + tmpvar_89);\n      vec2 tmpvar_91;\n      tmpvar_91.x = dot (p_90, vec2(127.1, 311.7));\n      tmpvar_91.y = dot (p_90, vec2(269.5, 183.3));\n      p_90 = tmpvar_91;\n      vec2 tmpvar_92;\n      tmpvar_92 = fract((sin(tmpvar_91) * 18.5453));\n      vec2 tmpvar_93;\n      tmpvar_93 = ((tmpvar_89 - fpos_73) + tmpvar_92);\n      float tmpvar_94;\n      tmpvar_94 = dot (tmpvar_93, tmpvar_93);\n      if ((tmpvar_94 < m_72.x)) {\n        vec3 tmpvar_95;\n        tmpvar_95.x = tmpvar_94;\n        tmpvar_95.yz = tmpvar_92;\n        m_72 = tmpvar_95;\n      };\n    };\n    col_15 = (tmpvar_43 * (1.0 - clamp (\n      (abs(((\n        (2.0 * m_19.z)\n       - m_46.z) - m_72.z)) * 1000.0)\n    , 0.0, 1.0)));\n    tmpvar_2 = (vec4(0.957, 0.988, 0.976, 1.0) * float((col_15.x >= 0.1)));\n    float tmpvar_96;\n    tmpvar_96 = clamp (((\n      (col_15.x * 2.0)\n     - 0.9) / 0.1), 0.0, 1.0);\n    tmpvar_1 = (vec4(0.857, 0.888, 0.98, 1.0) * (tmpvar_96 * (tmpvar_96 * \n      (3.0 - (2.0 * tmpvar_96))\n    )));\n  };\n  highp vec4 color_97;\n  float pf_98;\n  light_accumulator_ambient = tmpvar_7;\n  float tmpvar_99;\n  tmpvar_99 = clamp (dot (v_normal, -(tmpvar_10)), 0.0, 1.0);\n  light_accumulator_diffuse = (tmpvar_8 * tmpvar_99);\n  pf_98 = 0.0;\n  if ((tmpvar_99 > 0.0)) {\n    pf_98 = pow (max (dot (\n      normalize(v_eyeToPoint)\n    , \n      (tmpvar_10 - (2.0 * (dot (v_normal, tmpvar_10) * v_normal)))\n    ), 0.0), tmpvar_13);\n  };\n  light_accumulator_specular = (tmpvar_9 * pf_98);\n  float pf_100;\n  vec3 x_101;\n  x_101 = (tmpvar_6.xyz - v_eyeToPoint);\n  vec3 tmpvar_102;\n  tmpvar_102 = ((tmpvar_6.xyz - v_eyeToPoint) / sqrt(dot (x_101, x_101)));\n  float tmpvar_103;\n  tmpvar_103 = clamp (dot (tmpvar_102, v_normal), 0.0, 1.0);\n  light_accumulator_ambient = (tmpvar_7 + tmpvar_3);\n  light_accumulator_diffuse = (light_accumulator_diffuse + (tmpvar_4 * tmpvar_103));\n  pf_100 = 0.0;\n  if ((tmpvar_103 > 0.0)) {\n    vec3 I_104;\n    I_104 = -(tmpvar_102);\n    pf_100 = pow (max (0.0, dot (\n      -(normalize(v_eyeToPoint))\n    , \n      (I_104 - (2.0 * (dot (v_normal, I_104) * v_normal)))\n    )), tmpvar_13);\n  };\n  light_accumulator_specular = (light_accumulator_specular + (tmpvar_5 * pf_100));\n  color_97 = (tmpvar_1 + ((light_accumulator_ambient * color_14) * tmpvar_11));\n  color_97 = (color_97 + ((light_accumulator_diffuse * color_14) * tmpvar_12));\n  color_97 = (color_97 + (light_accumulator_specular * tmpvar_2));\n  highp vec4 tmpvar_105;\n  tmpvar_105 = clamp (color_97, 0.0, 1.0);\n  color_97 = tmpvar_105;\n  color_14.w = tmpvar_105.w;\n  color_14.xyz = (tmpvar_105.xyz + vec3(min ((1.0 - \n    ((v_world_position.z * 0.001) + 0.7)\n  ), 0.5)));\n  highp vec2 tmpvar_106;\n  tmpvar_106 = ((gl_FragCoord.xy / u_resolution) - vec2(0.5, 0.5));\n  highp vec2 p_107;\n  p_107 = (gl_FragCoord.xy * 0.6);\n  highp float s_108;\n  highp vec2 tmpvar_109;\n  tmpvar_109 = floor(p_107);\n  highp vec2 tmpvar_110;\n  tmpvar_110 = fract(p_107);\n  highp float tmpvar_111;\n  tmpvar_111 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_109.x) + (tmpvar_109.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_109.y * 13.0) + tmpvar_109.x)))\n  )));\n  highp vec2 p_112;\n  p_112 = (tmpvar_109 + vec2(1.0, 0.0));\n  highp float tmpvar_113;\n  tmpvar_113 = fract(((10000.0 * \n    sin(((17.0 * p_112.x) + (p_112.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_112.y * 13.0) + p_112.x)))\n  )));\n  highp vec2 p_114;\n  p_114 = (tmpvar_109 + vec2(0.0, 1.0));\n  highp vec2 p_115;\n  p_115 = (tmpvar_109 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_116;\n  tmpvar_116 = ((tmpvar_110 * tmpvar_110) * (3.0 - (2.0 * tmpvar_110)));\n  s_108 = (0.5 * ((\n    mix (tmpvar_111, tmpvar_113, tmpvar_116.x)\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_114.x)\n       + \n        (p_114.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_114.y * 13.0) + p_114.x)\n      ))))\n    ) - tmpvar_111) * tmpvar_116.y) * (1.0 - tmpvar_116.x))\n  ) + (\n    ((fract((\n      (10000.0 * sin(((17.0 * p_115.x) + (p_115.y * 0.1))))\n     * \n      (0.1 + abs(sin((\n        (p_115.y * 13.0)\n       + p_115.x))))\n    )) - tmpvar_113) * tmpvar_116.x)\n   * tmpvar_116.y)));\n  p_107 = (p_107 * 2.0);\n  highp vec2 tmpvar_117;\n  tmpvar_117 = floor(p_107);\n  highp vec2 tmpvar_118;\n  tmpvar_118 = fract(p_107);\n  highp float tmpvar_119;\n  tmpvar_119 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_117.x) + (tmpvar_117.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_117.y * 13.0) + tmpvar_117.x)))\n  )));\n  highp vec2 p_120;\n  p_120 = (tmpvar_117 + vec2(1.0, 0.0));\n  highp float tmpvar_121;\n  tmpvar_121 = fract(((10000.0 * \n    sin(((17.0 * p_120.x) + (p_120.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_120.y * 13.0) + p_120.x)))\n  )));\n  highp vec2 p_122;\n  p_122 = (tmpvar_117 + vec2(0.0, 1.0));\n  highp vec2 p_123;\n  p_123 = (tmpvar_117 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_124;\n  tmpvar_124 = ((tmpvar_118 * tmpvar_118) * (3.0 - (2.0 * tmpvar_118)));\n  s_108 = (s_108 + (0.25 * (\n    (mix (tmpvar_119, tmpvar_121, tmpvar_124.x) + (((\n      fract(((10000.0 * sin(\n        ((17.0 * p_122.x) + (p_122.y * 0.1))\n      )) * (0.1 + abs(\n        sin(((p_122.y * 13.0) + p_122.x))\n      ))))\n     - tmpvar_119) * tmpvar_124.y) * (1.0 - tmpvar_124.x)))\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_123.x)\n       + \n        (p_123.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_123.y * 13.0) + p_123.x)\n      ))))\n    ) - tmpvar_121) * tmpvar_124.x) * tmpvar_124.y)\n  )));\n  p_107 = (p_107 * 2.0);\n  color_14.xyz = (color_14.xyz - (dot (tmpvar_106, tmpvar_106) + (\n    (s_108 / 0.75)\n   * 0.1)));\n  gl_FragColor = color_14;\n}\n\n"
      defines:
        STYLE: modern-buildings
    texcoords: true
    base: polygons
  offices:
    base: polygons
    texcoords: true
    material:
      shininess: 1.
      emission: 0.0
      specular: 0.0
    shaders:
      blocks:
        vertex_shader: "precision highp float;\nuniform mat4 u_model;\nuniform mat4 u_modelView;\nuniform mat4 u_modelViewProj;\nuniform mat3 u_normalMatrix;\nuniform vec3 u_tile_origin;\nattribute vec4 a_position;\nattribute vec4 a_color;\nattribute vec3 a_normal;\nattribute vec2 a_texcoord;\nattribute float a_layer;\nvarying vec4 v_color;\nvarying vec3 v_eyeToPoint;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvarying vec4 v_world_position;\nvarying vec3 v_normalModel;\nvoid main ()\n{\n  v_normalModel = a_normal;\n  v_color = a_color;\n  v_eyeToPoint = (u_modelView * a_position).xyz;\n  v_normal = normalize((u_normalMatrix * a_normal));\n  v_texcoord = a_texcoord;\n  v_world_position = (u_model * a_position);\n  v_world_position.xy = (v_world_position.xy - (floor(\n    (u_tile_origin / vec3(100000.0, 100000.0, 100000.0))\n  ) * vec3(100000.0, 100000.0, 100000.0)).xy);\n  gl_Position = (u_modelViewProj * a_position);\n  gl_Position.z = (gl_Position.z / (1.0 + (0.1 * \n    (abs(u_tile_origin.z) - u_tile_origin.z)\n  )));\n  gl_Position.z = (gl_Position.z - ((a_layer * 1.5e-05) * gl_Position.w));\n}\n\n"
        fragment_shader: "precision highp float;\nstruct Material {\n  vec4 emission;\n  vec4 ambient;\n  vec4 diffuse;\n  vec4 specular;\n  float shininess;\n};\nstruct DirectionalLight {\n  vec4 ambient;\n  vec4 diffuse;\n  vec4 specular;\n  vec3 direction;\n};\nstruct PointLight {\n  vec4 ambient;\n  vec4 diffuse;\n  vec4 specular;\n  vec4 position;\n};\nuniform vec2 u_resolution;\nvarying vec4 v_color;\nvarying vec3 v_eyeToPoint;\nvarying vec3 v_normal;\nvarying vec2 v_texcoord;\nvarying vec4 v_world_position;\nuniform Material u_material;\nhighp vec4 tmpvar_1;\nvec4 tmpvar_2;\nvec4 light_accumulator_ambient;\nvec4 light_accumulator_diffuse;\nvec4 light_accumulator_specular;\nuniform DirectionalLight u_directional1;\nuniform PointLight u_point1;\nvarying vec3 v_normalModel;\nvoid main ()\n{\n  vec4 tmpvar_3;\n  vec4 tmpvar_4;\n  vec4 tmpvar_5;\n  vec4 tmpvar_6;\n  vec4 tmpvar_7;\n  vec4 tmpvar_8;\n  vec4 tmpvar_9;\n  vec3 tmpvar_10;\n  vec4 tmpvar_11;\n  vec4 tmpvar_12;\n  float tmpvar_13;\n  tmpvar_11 = u_material.ambient;\n  tmpvar_12 = u_material.diffuse;\n  tmpvar_13 = u_material.shininess;\n  tmpvar_1 = u_material.emission;\n  tmpvar_2 = u_material.specular;\n  light_accumulator_ambient = vec4(0.0, 0.0, 0.0, 0.0);\n  light_accumulator_diffuse = vec4(0.0, 0.0, 0.0, 0.0);\n  light_accumulator_specular = vec4(0.0, 0.0, 0.0, 0.0);\n  tmpvar_7 = u_directional1.ambient;\n  tmpvar_8 = u_directional1.diffuse;\n  tmpvar_9 = u_directional1.specular;\n  tmpvar_10 = u_directional1.direction;\n  tmpvar_3 = u_point1.ambient;\n  tmpvar_4 = u_point1.diffuse;\n  tmpvar_5 = u_point1.specular;\n  tmpvar_6 = u_point1.position;\n  highp vec4 color_14;\n  color_14.w = v_color.w;\n  color_14.xyz = (v_color.xyz * vec3(min ((\n    (v_world_position.z * 0.001)\n   + 0.5), 1.0)));\n  if ((v_normalModel.z == 0.0)) {\n    vec2 tmpvar_15;\n    tmpvar_15.x = (v_texcoord.x * 10.0);\n    tmpvar_15.y = (v_world_position.z * 0.2);\n    vec2 tmpvar_16;\n    tmpvar_16 = floor(tmpvar_15);\n    vec2 tmpvar_17;\n    tmpvar_17 = fract(tmpvar_15);\n    float tmpvar_18;\n    tmpvar_18 = float((tmpvar_17.x >= 0.01));\n    float tmpvar_19;\n    tmpvar_19 = float((tmpvar_17.y >= 0.1));\n    if (((tmpvar_18 * tmpvar_19) > 0.0)) {\n      tmpvar_2 = vec4(max ((1.0 - (\n        (v_world_position.z * 0.001)\n       + 0.5)), 0.0));\n      vec2 p_20;\n      p_20 = ((tmpvar_16 * vec2(1e-07, 0.01)) + floor((v_normal.xy * 10.0)));\n      tmpvar_1 = (vec4(0.957, 0.988, 0.976, 1.0) * float((\n        fract(((10000.0 * sin(\n          ((17.0 * p_20.x) + (p_20.y * 0.1))\n        )) * (0.1 + abs(\n          sin(((p_20.y * 13.0) + p_20.x))\n        ))))\n       >= 0.5)));\n      tmpvar_1 = (tmpvar_1 * (vec4(0.988, 0.983, 0.88, 1.0) * float(\n        (fract(((10000.0 * \n          sin(((17.0 * tmpvar_16.x) + (tmpvar_16.y * 0.1)))\n        ) * (0.1 + \n          abs(sin(((tmpvar_16.y * 13.0) + tmpvar_16.x)))\n        ))) >= 0.5)\n      )));\n    };\n  };\n  highp vec4 color_21;\n  float pf_22;\n  light_accumulator_ambient = tmpvar_7;\n  float tmpvar_23;\n  tmpvar_23 = clamp (dot (v_normal, -(tmpvar_10)), 0.0, 1.0);\n  light_accumulator_diffuse = (tmpvar_8 * tmpvar_23);\n  pf_22 = 0.0;\n  if ((tmpvar_23 > 0.0)) {\n    pf_22 = pow (max (dot (\n      normalize(v_eyeToPoint)\n    , \n      (tmpvar_10 - (2.0 * (dot (v_normal, tmpvar_10) * v_normal)))\n    ), 0.0), tmpvar_13);\n  };\n  light_accumulator_specular = (tmpvar_9 * pf_22);\n  float pf_24;\n  vec3 x_25;\n  x_25 = (tmpvar_6.xyz - v_eyeToPoint);\n  vec3 tmpvar_26;\n  tmpvar_26 = ((tmpvar_6.xyz - v_eyeToPoint) / sqrt(dot (x_25, x_25)));\n  float tmpvar_27;\n  tmpvar_27 = clamp (dot (tmpvar_26, v_normal), 0.0, 1.0);\n  light_accumulator_ambient = (tmpvar_7 + tmpvar_3);\n  light_accumulator_diffuse = (light_accumulator_diffuse + (tmpvar_4 * tmpvar_27));\n  pf_24 = 0.0;\n  if ((tmpvar_27 > 0.0)) {\n    vec3 I_28;\n    I_28 = -(tmpvar_26);\n    pf_24 = pow (max (0.0, dot (\n      -(normalize(v_eyeToPoint))\n    , \n      (I_28 - (2.0 * (dot (v_normal, I_28) * v_normal)))\n    )), tmpvar_13);\n  };\n  light_accumulator_specular = (light_accumulator_specular + (tmpvar_5 * pf_24));\n  color_21 = (tmpvar_1 + ((light_accumulator_ambient * color_14) * tmpvar_11));\n  color_21 = (color_21 + ((light_accumulator_diffuse * color_14) * tmpvar_12));\n  color_21 = (color_21 + (light_accumulator_specular * tmpvar_2));\n  highp vec4 tmpvar_29;\n  tmpvar_29 = clamp (color_21, 0.0, 1.0);\n  color_21 = tmpvar_29;\n  color_14.w = tmpvar_29.w;\n  color_14.xyz = (tmpvar_29.xyz + vec3(min ((1.0 - \n    ((v_world_position.z * 0.001) + 0.7)\n  ), 0.5)));\n  highp vec2 tmpvar_30;\n  tmpvar_30 = ((gl_FragCoord.xy / u_resolution) - vec2(0.5, 0.5));\n  highp vec2 p_31;\n  p_31 = (gl_FragCoord.xy * 0.6);\n  highp float s_32;\n  highp vec2 tmpvar_33;\n  tmpvar_33 = floor(p_31);\n  highp vec2 tmpvar_34;\n  tmpvar_34 = fract(p_31);\n  highp float tmpvar_35;\n  tmpvar_35 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_33.x) + (tmpvar_33.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_33.y * 13.0) + tmpvar_33.x)))\n  )));\n  highp vec2 p_36;\n  p_36 = (tmpvar_33 + vec2(1.0, 0.0));\n  highp float tmpvar_37;\n  tmpvar_37 = fract(((10000.0 * \n    sin(((17.0 * p_36.x) + (p_36.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_36.y * 13.0) + p_36.x)))\n  )));\n  highp vec2 p_38;\n  p_38 = (tmpvar_33 + vec2(0.0, 1.0));\n  highp vec2 p_39;\n  p_39 = (tmpvar_33 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_40;\n  tmpvar_40 = ((tmpvar_34 * tmpvar_34) * (3.0 - (2.0 * tmpvar_34)));\n  s_32 = (0.5 * ((\n    mix (tmpvar_35, tmpvar_37, tmpvar_40.x)\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_38.x)\n       + \n        (p_38.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_38.y * 13.0) + p_38.x)\n      ))))\n    ) - tmpvar_35) * tmpvar_40.y) * (1.0 - tmpvar_40.x))\n  ) + (\n    ((fract((\n      (10000.0 * sin(((17.0 * p_39.x) + (p_39.y * 0.1))))\n     * \n      (0.1 + abs(sin((\n        (p_39.y * 13.0)\n       + p_39.x))))\n    )) - tmpvar_37) * tmpvar_40.x)\n   * tmpvar_40.y)));\n  p_31 = (p_31 * 2.0);\n  highp vec2 tmpvar_41;\n  tmpvar_41 = floor(p_31);\n  highp vec2 tmpvar_42;\n  tmpvar_42 = fract(p_31);\n  highp float tmpvar_43;\n  tmpvar_43 = fract(((10000.0 * \n    sin(((17.0 * tmpvar_41.x) + (tmpvar_41.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((tmpvar_41.y * 13.0) + tmpvar_41.x)))\n  )));\n  highp vec2 p_44;\n  p_44 = (tmpvar_41 + vec2(1.0, 0.0));\n  highp float tmpvar_45;\n  tmpvar_45 = fract(((10000.0 * \n    sin(((17.0 * p_44.x) + (p_44.y * 0.1)))\n  ) * (0.1 + \n    abs(sin(((p_44.y * 13.0) + p_44.x)))\n  )));\n  highp vec2 p_46;\n  p_46 = (tmpvar_41 + vec2(0.0, 1.0));\n  highp vec2 p_47;\n  p_47 = (tmpvar_41 + vec2(1.0, 1.0));\n  highp vec2 tmpvar_48;\n  tmpvar_48 = ((tmpvar_42 * tmpvar_42) * (3.0 - (2.0 * tmpvar_42)));\n  s_32 = (s_32 + (0.25 * (\n    (mix (tmpvar_43, tmpvar_45, tmpvar_48.x) + (((\n      fract(((10000.0 * sin(\n        ((17.0 * p_46.x) + (p_46.y * 0.1))\n      )) * (0.1 + abs(\n        sin(((p_46.y * 13.0) + p_46.x))\n      ))))\n     - tmpvar_43) * tmpvar_48.y) * (1.0 - tmpvar_48.x)))\n   + \n    (((fract(\n      ((10000.0 * sin((\n        (17.0 * p_47.x)\n       + \n        (p_47.y * 0.1)\n      ))) * (0.1 + abs(sin(\n        ((p_47.y * 13.0) + p_47.x)\n      ))))\n    ) - tmpvar_45) * tmpvar_48.x) * tmpvar_48.y)\n  )));\n  p_31 = (p_31 * 2.0);\n  color_14.xyz = (color_14.xyz - (dot (tmpvar_30, tmpvar_30) + (\n    (s_32 / 0.75)\n   * 0.1)));\n  gl_FragColor = color_14;\n}\n\n"
      defines:
        STYLE: offices
sources:
  osm:
    type: MVT
    url: https://vector.mapzen.com/osm/all/{z}/{x}/{y}.mvt
layers:
  water:
    data: {source: osm}
    filter:
      any:
        - {area: {min: 10000000}, $zoom: {min: 0}}
        - {$zoom: {min: 10}, area: {min: 1000000}}
        - {area: {min: 100000}, $zoom: {min: 12}}
        - {area: {min: 1000}, $zoom: {min: 15}}
        - {$zoom: {min: 18}}
    draw:
      grain:
        color: !<!> "#353535"
        order: 2
  earth:
    data: {source: osm}
    draw:
      grain:
        order: 0
        color: !<!> "#555"
  landuse:
    data: {source: osm}
    draw:
      grain:
        order: 1
        color: !<!> "#666"
  roads:
    draw:
      roads:
        order: 2
        width: [[0, 2.], [15, 4.0]]
        color: black
    data: {source: osm}
    filter: {not: {kind: rail, highway: service}}
    oneway:
      draw: {roads: {color: red}}
      filter: {oneway: yes}
  buildings:
    data: {source: osm}
    draw:
      polygons:
        color: !<!> "#999"
        order: 50
    modern:
      filter: {kind: museum, $zoom: {min: 10}}
      draw:
        modern-buildings:
          color: !<!> "#999"
          order: 50
    filter: {$zoom: {min: 10}}
    offices:
      filter: function(){ return feature.height > 100; }
      draw:
        offices:
          extrude: function() { return feature.height > 0 || $zoom >= 16; }
          order: 50
          color: !<!> "#999"
    apartments:
      filter: function(){ return feature.height < 100; }
      draw:
        buildings:
          order: 50
          color: !<!> "#999"
          extrude: function() { return feature.height > 0 || $zoom >= 16; }